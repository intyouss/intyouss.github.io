<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3月5日 学习记录</title>
    <url>/2023/03/05/3%E6%9C%885%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="flask中函数app-route-嵌套装饰器可能错误"><a href="#flask中函数app-route-嵌套装饰器可能错误" class="headerlink" title="flask中函数app.route()嵌套装饰器可能错误"></a>flask中函数app.route()嵌套装饰器可能错误</h4><hr>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">atuh1</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*arg, **kwarg</span>):</span><br><span class="line">        <span class="keyword">return</span> func(*arg, **kwarg)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">atuh2</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*arg, **kwarg</span>):</span><br><span class="line">        <span class="keyword">return</span> func(*arg, **kwarg)</span><br><span class="line">    <span class="keyword">return</span> inner    </span><br><span class="line"></span><br><span class="line"><span class="meta">@auth1</span></span><br><span class="line"><span class="meta">@auth2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;index&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>单装饰器装饰: 装饰器在装饰一个函数时，此函数将被装饰器内部函数替代，如果想暴露原本函数，可以使用装饰器@functools.wraps(func)</p>
<p>多装饰器装饰: 优先使用内部装饰器，逐层向上</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/index&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;h&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/login&quot;</span></span>)</span></span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;g&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>@app.route() endpoint默认为函数名  </p>
<p>两个函数使用相同函数装饰auth, 在不使用@functools.warps(func)的情况下，两个初始函数被装饰后，都将变为inner的属性，形成别名重复错误:<br><code>AssertionError: View function mapping is ovwewriting an existing endpoint function: inner</code></p>
<h4 id="flask蓝图"><a href="#flask蓝图" class="headerlink" title="flask蓝图"></a>flask蓝图</h4><hr>
<p>flask蓝图主要功能就是分类(Blueprint)，不同功能函数放在不同文件中实现: </p>
<ol>
<li><p>创建蓝图</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">xxx = Blueprint(<span class="string">&#x27;xxx&#x27;</span>, __name__)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在主进程中引用蓝图</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="string">&#x27;/path&#x27;</span> <span class="keyword">import</span> xxx</span><br><span class="line">app.register_blueprint(xxx, url_prefix=<span class="string">&#x27;/x&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>url_prefix 添加前缀 使用: &#x2F;x&#x2F;xxx</p>
</li>
</ol>
<h4 id="Django的路由映射和Flask的蓝图有什么区别"><a href="#Django的路由映射和Flask的蓝图有什么区别" class="headerlink" title="Django的路由映射和Flask的蓝图有什么区别"></a>Django的路由映射和Flask的蓝图有什么区别</h4><hr>
<p>flask:</p>
<ol>
<li><p>flask是利用蓝图进行模块划分的，通过app装饰器注册模块蓝图，在主模块统一调用;</p>
</li>
<li><p>在flask中，路由是通过装饰器给每个视图函数提供的, 而且根据请求方式的不同可以一个url用于不同的作用。功能相似，但是底层实现不一样</p>
</li>
</ol>
<p>Django:</p>
<ol>
<li>Django路由映射是通过路由正则匹配映射到每一个模块的</li>
<li>在django中，路由是浏览器访问服务器时，先访问的项目中的url，再由项目中的url找到应用中url，这些url是放在一个列表里，遵从从前往后匹配的规则。</li>
</ol>
]]></content>
      <tags>
        <tag>Flask Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Django</title>
    <url>/2023/03/25/Django/</url>
    <content><![CDATA[<h3 id="Django-MVT"><a href="#Django-MVT" class="headerlink" title="Django MVT"></a>Django MVT</h3><ul>
<li><p>网站设计的三层架构</p>
</li>
<li><p>借鉴于Java的MVC(C: Controller)</p>
</li>
</ul>
<p>M(Model数据模型: 数据层)V(View视图层: 控制层)T(Templete模板层(在MVC中为视图层))</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-03-25-12-39-38-image.png"
                     
                ></p>
<h3 id="创建Django工程文件"><a href="#创建Django工程文件" class="headerlink" title="创建Django工程文件"></a>创建Django工程文件</h3><p>django-admin startproject 文件名</p>
<p>内部生成文件</p>
<ul>
<li><p>manage.py 内置django命令</p>
</li>
<li><p>settings 配置文件</p>
</li>
<li><p>urls 路由文件</p>
</li>
<li><p>wsgi 网关系统 在互联网中可以被其他计算机访问的文件</p>
</li>
</ul>
<h3 id="运行Django工程"><a href="#运行Django工程" class="headerlink" title="运行Django工程"></a>运行Django工程</h3><p>manage.py 内置测试服务器运行指令</p>
<p>python3 manage.py runserver (默认8000端口)</p>
<h3 id="创建子应用"><a href="#创建子应用" class="headerlink" title="创建子应用"></a>创建子应用</h3><p>python3  manage.py startapp 应用名</p>
<p>内部生成文件</p>
<ul>
<li><p>admin.py 与网站后台管理站点配置相关</p>
</li>
<li><p>apps.py 用于配置当前子应用的相关信息</p>
</li>
<li><p>mifrations 用于存储数据库迁移历史文件</p>
</li>
<li><p>models.py 用户保存数据库模型类</p>
</li>
<li><p>tests.py 用于开发测试用例，编写单元测试</p>
</li>
<li><p>views.py 用于编写web应用视图</p>
</li>
</ul>
<h3 id="Setting配置"><a href="#Setting配置" class="headerlink" title="Setting配置"></a>Setting配置</h3><ul>
<li><p>ALLOWED_HOSTS &#x3D; [‘*’] 允许访问的主机</p>
</li>
<li><p>INSTALLED_APPS &#x3D; [‘app’] 应用注册，app在创建后在此注册应用</p>
</li>
</ul>
<h3 id="外键的优缺点"><a href="#外键的优缺点" class="headerlink" title="外键的优缺点"></a>外键的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li><p>由数据库自身保证数据一致性和完整性，数据更可靠</p>
</li>
<li><p>可以增加ER图的可读性</p>
</li>
<li><p>外键可以节省开发量</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h4><ul>
<li><p>性能确实，有额外的开销</p>
</li>
<li><p>主键表被锁定时，会引发外键表也被锁</p>
</li>
<li><p>删除主键表的数据时，需先删除外键表的数据</p>
</li>
<li><p>修改外键表字段时，需重建外键约束</p>
</li>
<li><p>不能用于分布式环境</p>
</li>
<li><p>不容易做到数据解耦</p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p>适用</p>
<p>内部系统，传统企业级，规模可控的环境</p>
</li>
<li><p>不适用</p>
<p>规模不可控的环境, 数量大</p>
</li>
</ul>
<p>on_delete:</p>
<ul>
<li><p>models.SET_NULL<br>置空模式，删除时，外键字段被设置为空，前提就是blank&#x3D;True, null&#x3D;True,定义该字段时，允许为空。理解：删除关联数据（子表），与之关联的值设置默认值为null（父表中），这个前提需要父表中的字段可以为空。<br>PS:外键写在多处，且写外键只能是主键，如没设置主键，django会自动帮你创</p>
</li>
<li><p>None：<br>删除关联表的数据时，当前表与关联表的filed的行为。</p>
</li>
<li><p>models.CASCADE：<br>表示级联删除，当关联表（子表）中的数据删除时，与其相对应的外键（父表）中的数据也删除。</p>
</li>
<li><p>models.DO_NOTHING:<br>你删你的，父亲（外键）不想管你</p>
</li>
<li><p>models.PROTECT:<br>保护模式，如采用这个方法，在删除关联数据时会抛出ProtectError错误</p>
</li>
<li><p>models.SET_DEFAULT:<br>设置默认值，删除子表字段时，外键字段设置为默认值，所以定义外键的时候注意加上一个默认值。</p>
</li>
<li><p>on_delete &#x3D; models.SET（值）:<br>删除关联数据时，自定义一个值，该值只能是对应指定的实体</p>
</li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ol>
<li><p>视图函数必须定义一个参数(通常命名为request)</p>
<ul>
<li>request: 用来接收客户端的请求信息的</li>
</ul>
</li>
<li><p>视图函数的返回值必须是一个HttpResponse的对象</p>
</li>
</ol>
<h4 id="视图使用的流程"><a href="#视图使用的流程" class="headerlink" title="视图使用的流程"></a>视图使用的流程</h4><ol>
<li><p>在应用的views.py定义视图函数</p>
</li>
<li><p>配置路由</p>
<ul>
<li><p>在项目目录的urls.py中关联应用下的urls.py</p>
</li>
<li><p>在应用的目录下定义一个urls.py文件</p>
</li>
<li><p>配置具体的访问规则</p>
<p><code>urlpatterns = [path(&#39;路由名&#39;, 包路径)]</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="admin-Django默认后台"><a href="#admin-Django默认后台" class="headerlink" title="admin Django默认后台"></a>admin Django默认后台</h3><ol>
<li><p>配置admin账户密码</p>
<ul>
<li><code>python manage.py createsuperuser</code></li>
</ul>
</li>
</ol>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="模板的配置和使用步骤"><a href="#模板的配置和使用步骤" class="headerlink" title="模板的配置和使用步骤:"></a>模板的配置和使用步骤:</h4><ol>
<li><p>在项目目录下创建一个templates文件夹</p>
</li>
<li><p>在setting.py中TEMPLATES选项中配置项目模板的根路径</p>
<p><code>&#39;DIRS&#39;: [BASE_DIR / &#39;templates&#39;]</code></p>
</li>
<li><p>在templates中创建和应用同名文件夹</p>
</li>
<li><p>在templates下应用同名的文件夹中创建html模板页面</p>
</li>
<li><p>在views.py中定义视图函数, 并返回html模板页面</p>
<ul>
<li><p>参数:</p>
<ul>
<li><p>第一个请求对象</p>
</li>
<li><p>第二个模板路径</p>
</li>
<li><p>第三个要渲染到模板中的数据(必须是字典)</p>
</li>
</ul>
</li>
</ul>
<p><code>return render(request, &#39;news/list.html&#39;, info)</code></p>
</li>
<li><p>配置路由访问规则</p>
</li>
</ol>
<h3 id="修改数据库为MySQL"><a href="#修改数据库为MySQL" class="headerlink" title="修改数据库为MySQL"></a>修改数据库为MySQL</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改为:</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>:<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h3><ol>
<li><p>调用<code>from Django.db import models</code></p>
</li>
<li><p>创建模型类<code>class 模型名(models.Model)</code></p>
</li>
<li><p>设置属性</p>
</li>
<li><p>表名自定义:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">模型名</span>(models.Model):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        <span class="comment"># set the table&#x27;s name</span></span><br><span class="line">        db_table = <span class="string">&#x27;newinfo&#x27;</span></span><br><span class="line">        <span class="comment"># set the table&#x27;s info</span></span><br><span class="line">        verbose_name = <span class="string">&quot;new&#x27;s info&quot;</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="模型表迁移"><a href="#模型表迁移" class="headerlink" title="模型表迁移"></a>模型表迁移</h3><p><code>python manage.py makemigration</code></p>
<p><code>python manage.py migrate</code></p>
<h3 id="自定义admin后台"><a href="#自定义admin后台" class="headerlink" title="自定义admin后台"></a>自定义admin后台</h3><ol>
<li><p>进入admin.py</p>
</li>
<li><p>新建类<code>class admin类(admin.ModelAdmin)</code></p>
</li>
<li><p>将模型中的属性都放入admin类中的list_display中</p>
<p><code>list_display = [&#39;id&#39;, &#39;name&#39;]</code></p>
</li>
<li><p>注册绑定类<code>admin.site.register(模型名，admin模型名)</code></p>
</li>
</ol>
<h3 id="模型类的查询方法"><a href="#模型类的查询方法" class="headerlink" title="模型类的查询方法"></a>模型类的查询方法</h3><h4 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h4><ul>
<li><p>get方法: 查询一条数据</p>
<p>查询id为1的数据</p>
<p><code>NewsType.object.get(id=1)</code></p>
<p>特点: 只能查询唯一满足条件的数据</p>
<blockquote>
<p>没有找到符合条件的数据，直接报错(DoesNotExist)</p>
<p>查询出多条符合条件数据，也会报错(MultipleObjectReturned)</p>
</blockquote>
</li>
<li><p>filter方法: 根据条件过滤查询</p>
<blockquote>
<p>返回的值是一个quertSet对象(查询集)</p>
</blockquote>
</li>
<li><p>all方法: 返回模块类对应的表中所有数据</p>
<blockquote>
<p>返回的值是一个querSet对象(查询集)</p>
</blockquote>
</li>
<li><p>exclude方法: 查询不符合条件的数据</p>
<p>查询name不是实时政治的</p>
<p><code>NewsType.object.exclude(name=&#39;实时政治&#39;)</code></p>
</li>
<li><p>order_by: 排序方法</p>
<p>根据新闻的阅读量进行排序(升序)</p>
<p><code>NewsInfo.object.all().order_by(&#39;read&#39;)</code></p>
<p>(降序)</p>
<p><code>NewsInfo.object.all().order_by(&#39;-read&#39;)</code></p>
<ul>
<li><p>排序规则:</p>
<blockquote>
<p>默认是从小到大(升序)</p>
<p>降序排序在字段前面加一个’-‘</p>
</blockquote>
</li>
</ul>
</li>
<li><p>查询集:</p>
<ul>
<li><p>支持索引取值</p>
</li>
<li><p>支持切片</p>
</li>
<li><p>支持再次调用查询方法</p>
</li>
</ul>
</li>
</ul>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>条件语法格式:</p>
<ul>
<li>模型类.object.filter(模型类属性名__条件名&#x3D;值)</li>
</ul>
<blockquote>
<ul>
<li>包含: contains</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询名称里包含&#x27;娱乐&#x27;的新闻类别</span></span><br><span class="line">NewsInfo.objects.<span class="built_in">filter</span>(new_type__contains=<span class="string">&#x27;娱乐&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>开头: startswith</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询以&#x27;国&#x27;开头的新闻类别</span></span><br><span class="line">NewsInfo.objects.<span class="built_in">filter</span>(new_type__startswith=<span class="string">&#x27;国&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>结尾: endswith</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询以&#x27;资讯&#x27;结尾的新闻类别</span></span><br><span class="line">NewsInfo.objects.<span class="built_in">filter</span>(new_type__endswith=<span class="string">&#x27;资讯&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>范围查询: in</li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询id为1或3或5的新闻类别</span></span><br><span class="line">NewsInfo.objects.<span class="built_in">filter</span>(id__in=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure></div>
</blockquote>
<blockquote>
<p>比较查询</p>
<ul>
<li><p>大于: gt</p>
</li>
<li><p>小于: lt</p>
</li>
<li><p>大于等于: gte</p>
</li>
<li><p>小于等于: lte</p>
</li>
<li><p>字段值是否为Null: isnull</p>
<p>查询name不为空的字段</p>
<p><code>NewsType.objects.filter(name__isnull=False)</code></p>
</li>
</ul>
</blockquote>
<h4 id="F对象和Q对象"><a href="#F对象和Q对象" class="headerlink" title="F对象和Q对象"></a>F对象和Q对象</h4><ol>
<li><p>F对象: 用来比较查询数据的两个属性</p>
<blockquote>
<p>导入: <code>from django.db.models import F</code></p>
<p>查询 ‘阅读量’ 大于 ‘评论数量’两倍的新闻</p>
<p><code>NewsInfo.objects.filter(read__gt=F(&#39;comment&#39;)*2)</code></p>
<p>F对象查询结果可以直接进行算数运算</p>
</blockquote>
</li>
<li><p>Q对象: 逻辑查询(与或非)</p>
<blockquote>
<p>导入: <code>from django.db.models import Q</code></p>
<ol>
<li><p>逻辑与:</p>
<p>不使用Q对象:</p>
<p>查询阅读数量大于40，评论数量大于35的数据</p>
<p><code>NewsInfo.objects.filter(read__gt=40,comment__gt=35)</code></p>
<p>使用Q对象:</p>
<p><code>NewsInfo.objects.filter(Q(read__gt=40) &amp; Q(comment__gt=35))</code></p>
</li>
<li><p>逻辑或:</p>
<p><code>NewsInfo.objects.filter(Q(read__gt=40) | Q(comment__gt=35))</code></p>
</li>
<li><p>逻辑非:</p>
<p>通过 exclude查询:</p>
<p><code>NewsType.object.exclude(name=&#39;实时政治&#39;)</code></p>
<p>通过Q对象:</p>
<p><code>NewsType.object.exclude(~Q(name=&#39;实时政治&#39;))</code></p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="模型类关联查询"><a href="#模型类关联查询" class="headerlink" title="模型类关联查询"></a>模型类关联查询</h4><ol>
<li><p>通过对象进行关联查询</p>
<p><code>单一查询.模型类名_set.操作()</code></p>
<p>由一到多的查询:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">b = BookInfo.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">b.hero_set.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></div>

<p>由多到一的查询:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">b = BookInfo.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">b.book <span class="comment"># 属性名</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <tags>
        <tag>Django Study</tag>
      </tags>
  </entry>
  <entry>
    <title>3月9日项目问题</title>
    <url>/2023/03/09/3%E6%9C%889%E6%97%A5%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="读取yaml"><a href="#读取yaml" class="headerlink" title="读取yaml"></a>读取yaml</h4><p>引用<code>from ruamel import yaml</code></p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">yaml.load(</span><br><span class="line">    Path(<span class="string">&#x27;C:\\Users\\Lenovo\\Desktop\\bot\\IntBot\\configs\\config.yaml&#x27;</span>).read_text(encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    Loader=yaml.Loader</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h4 id="pydantic"><a href="#pydantic" class="headerlink" title="pydantic"></a>pydantic</h4><p><code>extra=&#39;ignore&#39;</code>忽略额外属性</p>
<h3 id="flask-migrate数据迁移"><a href="#flask-migrate数据迁移" class="headerlink" title="flask-migrate数据迁移"></a>flask-migrate数据迁移</h3><p>因为在开发中，由于数据表模型的改动，数据经常被清除，因此可以使用数据迁移，保存旧数据</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 设置数据库连接地址</span></span><br><span class="line">DB_URI = <span class="string">&#x27;mysql+pymysql://root:123456@127.0.0.1:3306/web&#x27;</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = DB_URI</span><br><span class="line"><span class="comment"># 是否追踪数据库修改，一般不开启, 会影响性能</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 是否显示底层执行的SQL语句</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化db,关联flask 项目</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"><span class="comment"># 迁移组件初始化</span></span><br><span class="line">Migrate(app, db)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Students</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;students&#x27;</span>  <span class="comment"># 数据库表名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">20</span>))</span><br><span class="line">    fullname = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line">    nickname = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;Students(name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;, fullname=&#x27;<span class="subst">&#123;self.fullname&#125;</span>&#x27;, nickname=&#x27;<span class="subst">&#123;self.nickname&#125;</span>&#x27;)&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Users</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;user&#x27;</span>  <span class="comment"># 数据库表名</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;&lt;Users(id=&#x27;<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>&#x27;, name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;)&gt;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>执行迁移命令，先设置环境变量, 如果启动文件是app.py 这步可以省略。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> FLASK_APP=app.py  <span class="comment"># 设置环境变量指定启动文件</span></span><br></pre></td></tr></table></figure></div>

<p>windows用set设置环境变量，linux 用export 设置环境变量</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FLASK_APP=app.py  <span class="comment"># 设置环境变量指定启动文件</span></span><br></pre></td></tr></table></figure></div>

<p>执行相关命令</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">flask db init  <span class="comment"># 生成迁移文件夹  只执行一次</span></span><br><span class="line">flask db migrate  <span class="comment"># ⽣成迁移版本, 保存到迁移文件夹中</span></span><br><span class="line">flask db upgrade  <span class="comment"># 执行迁移</span></span><br></pre></td></tr></table></figure></div>

<h4 id="迁移命令"><a href="#迁移命令" class="headerlink" title="迁移命令"></a>迁移命令</h4><p>init 命令执行后，会生成migrations目录</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">flask db init</span><br></pre></td></tr></table></figure></div>

<p>migrate 命令生成迁移脚本，保存到迁移文件夹中versions目录</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">flask db migrate</span><br></pre></td></tr></table></figure></div>

<p>upgrade 命令执行迁移</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">flask db upgrade</span><br></pre></td></tr></table></figure></div>

<p>执行完upgrade 命令才会在数据库中生成表</p>
<h3 id="虚拟环境直接复制迁移"><a href="#虚拟环境直接复制迁移" class="headerlink" title="虚拟环境直接复制迁移"></a>虚拟环境直接复制迁移</h3><ol>
<li><p>迁移到新电脑，将 虚拟环境文件夹内的pyvenv.cfg文件中home参数，写成新电脑python的路径</p>
</li>
<li><p>修改虚拟环境文件夹中Scripts中的activate内VIRTUAL_ENV参数修改成新电脑虚拟环境文件夹路径</p>
</li>
<li><p>修改虚拟文件夹中Scripts中的activate.bat内set “VIRTUAL_ENV参数改成新电脑虚拟环境文件夹路径</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>3月6日 学习记录</title>
    <url>/2023/03/06/3%E6%9C%886%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="唯一的URL-x2F-重定向行为"><a href="#唯一的URL-x2F-重定向行为" class="headerlink" title="唯一的URL&#x2F;重定向行为"></a>唯一的URL&#x2F;重定向行为</h3><hr>
<p>route内的元素表示不同，将有不同的限制</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/projects/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">projects</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/about&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">about</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>如果使用没有斜杠的&#x2F;projects访问，Flask会自动帮助添加斜杠，因此中规中矩，却有两种访问方式。  </p>
<p>如果使用有斜杠的&#x2F;about&#x2F;访问，将会返回一个404未找到错误，可以保证URL唯一性，并有助于搜索引擎重复索引同一个界面！</p>
<h3 id="flask的session"><a href="#flask的session" class="headerlink" title="flask的session"></a>flask的session</h3><hr>
<p>flask的session是以加密保存在浏览器上的，依赖于secret_key</p>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><hr>
<p>使用数据库连接池可以很好的解决链接数据库时，重复连接的问题</p>
<p>可以将数据库连接封装成一个函数或者类，方便调用</p>
<h4 id="With上下文管理-简"><a href="#With上下文管理-简" class="headerlink" title="With上下文管理(简)"></a>With上下文管理(简)</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">124</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="keyword">with</span> obj <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure></div>

<p>with一个对象会调用对象中的 属性__enter__ ，结束后调用属性__exit__。</p>
<p>使用上下文管理操控线程池的开关，可以实现线程自动化</p>
<h3 id="引入静态文件"><a href="#引入静态文件" class="headerlink" title="引入静态文件"></a>引入静态文件</h3><hr>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;&#123;</span> <span class="attr">url_for</span>(&#x27;<span class="attr">static</span>&#x27;, <span class="attr">filename</span>=<span class="string">&#x27;mm.jpg&#x27;</span>) &#125;&#125; /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>或</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;/static/mm.jpg&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在使用static_url_path&#x3D;’&#x2F;xx’修改static文件夹路径时，前一个可以在不做修改下实现自动识别static路径。后者需要一个一个修改，不利于使用。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><hr>
<p>使用函数加载配置文件:</p>
<p><code>app.config.from_object(&#39;config.settings&#39;)</code></p>
<p>使用配置文件:</p>
<p><code>app.config[&#39;xx&#39;]</code></p>
<ol>
<li><p>可以使用localsettings在本地测试, 覆盖settings, 保护原始文件</p>
<p>在settings添加:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> localsettings <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>        在上传服务器时，可以方便的在服务器和本地切换</p>
<p>        使用.gitgnore控制上传文件，忽略不需要的文件</p>
<ol start="2">
<li><p>类配置文件</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dev</span>(<span class="title class_ inherited__">obj</span>):</span><br><span class="line">    HOST = <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prod</span>(<span class="title class_ inherited__">obj</span>):</span><br><span class="line">    HOST = <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>        使用类隔离开发环境</p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><hr>
<ol>
<li><p>进程是cpu中执行的最小单元，线程是cpu中资源调度的最小单元，一个进程内可以有多个线程</p>
</li>
<li><p>接口<br>其他语言 :<br>接口是以interface关键字开头，内部定义方法，但不具体实现，专门用于约束实现类<br>类中可以有多个接口继承  </p>
<p>python :<br>无接口，可以多继承<br>但不能继承多个类</p>
</li>
<li><p>构造函数和析构函数<br>构造函数：用于创建对象的函数 class foo(obj)<br>析构函数：用于销毁对象的函数 del obj()</p>
</li>
<li><p>重写和重载的区别<br>重载：函数名相同而参数类型，个数，返回值不同<br>重写：在子类中，对父类的方法重写</p>
</li>
<li><p>抽象类和抽象方法<br>java :<br>抽象类中可以有抽象方法也可以有普通方法。<br>抽象类被继承后需要实现抽象方法</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Flask Study</tag>
      </tags>
  </entry>
  <entry>
    <title>3月7日学习记录</title>
    <url>/2023/03/07/3%E6%9C%887%E6%97%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h3><hr>
<h4 id="路由的两种写法"><a href="#路由的两种写法" class="headerlink" title="路由的两种写法"></a>路由的两种写法</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">app.add_url_rule(<span class="string">&#x27;/index&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, index)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/inddex&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="路由加载源码的流程"><a href="#路由加载源码的流程" class="headerlink" title="路由加载源码的流程"></a>路由加载源码的流程</h4><ul>
<li><p>将URL和函数打包成为Rule对象</p>
</li>
<li><p>将Rule对象添加到map对象中</p>
</li>
<li><p>app_url_map &#x3D; map对象</p>
</li>
</ul>
<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&lt;string:name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>uuid类型 类似于xxxxx-xxxxxxx-xxxxxx-xxxxxx</p>
<h5 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h5><p>必须继承BaseConverter</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegexConverter</span>(<span class="title class_ inherited__">BaseConverter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>, regex</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="built_in">map</span>)</span><br><span class="line">        self.regex = regex</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_python</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.url_map.converters[<span class="string">&#x27;regex&#x27;</span>] = RegexConverter</span><br></pre></td></tr></table></figure></div>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><hr>
<h4 id="FBV"><a href="#FBV" class="headerlink" title="FBV"></a>FBV</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user&#x27;</span>, method=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br></pre></td></tr></table></figure></div>

<h4 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h4><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserView</span>(views, MethodView):</span><br><span class="line">    method = [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span><br><span class="line">    decorators = [test1, test2] //CBV添加装饰器</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;post&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/user&#x27;</span>, view_func=UserView.as_view(<span class="string">&#x27;user&#x27;</span>))</span><br></pre></td></tr></table></figure></div>

<h3 id="模板-jinja2"><a href="#模板-jinja2" class="headerlink" title="模板(jinja2)"></a>模板(jinja2)</h3><hr>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>模板可继承</p>
<ol>
<li><p>被继承:</p>
<p><code>&#123;% block content %&#125; ? &#123;% endbloack %&#125;</code>  </p>
</li>
<li><p>继承:</p>
<p><code>&#123;% extends 'layout.html' %&#125;  &#123;% block content %&#125; ? &#123;% endbloack %&#125;</code></p>
</li>
<li><p>引入:</p>
<p><code>&#123;% include 'from.html' %&#125;</code></p>
</li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dunc</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">render_template(<span class="string">&#x27;md.html&#x27;</span>, nums=nums, f=func) //可以传递函数名</span><br></pre></td></tr></table></figure></div>

<p>定义全局模板方法</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.template_glabol() //模板中全局使用 &#123;&#123; func(<span class="params"><span class="string">&#x27;haha&#x27;</span></span>) &#125;&#125;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.template_filter() //模板全局使用 &#123;&#123; <span class="string">&#x27;haha&#x27;</span>|f(<span class="params"><span class="string">&#x27;e&#x27;</span></span>) &#125;&#125;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">arg,h</span>):</span><br><span class="line">    <span class="keyword">return</span> arg + h</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/md/hg&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;md_hg.html&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果想要将一个方法限制为一个蓝图域中使用，只需将app修改即可</p>
<h3 id="特殊装饰器"><a href="#特殊装饰器" class="headerlink" title="特殊装饰器"></a>特殊装饰器</h3><hr>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request //视图函数运行前运行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():// 一旦返回值为真，则停止行为向下传播(判断用户登录等), 反之空，则继续</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.after_request //视图函数运行结束后运行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">response</span>): //视图函数有返回值，就必须返回一个Responce</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;f2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>或</p>
<p><code>app.before_request(func)</code>不加装饰器使用</p>
]]></content>
      <tags>
        <tag>Flask Study</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-React-2</title>
    <url>/2023/03/08/JavaScript-React-2/</url>
    <content><![CDATA[<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><hr>
<h4 id="三大API"><a href="#三大API" class="headerlink" title="三大API"></a>三大API</h4><ol>
<li><p><code>React.createElement()</code>用来创建React元素，无法修改</p>
</li>
<li><p><code>React.createRoot()</code>用来创建React的根容器， 容器用来放置React元素</p>
</li>
<li><p><code>root.render()</code></p>
<ul>
<li><p>当首次调用时, 容器节点里的所有DOM元素都会被替换, 后续的调用则会使用React的DOM差分算法(DOM diffing alorithm) 进行高效更新</p>
</li>
<li><p>不会修改容器节点(只会修改容器的子节点), 可以在不覆盖现有子节点的情况下, 将组件插入已有的DOM节点中</p>
</li>
</ul>
</li>
</ol>
<h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h5><ol>
<li><p>JSX不是字符串, 不要加引号</p>
</li>
<li><p>JSX中html标签应该小写, React组件应该大写开头</p>
</li>
<li><p>JSX中有且只有一个根标签</p>
</li>
<li><p>jSX的标签必须正确结束<code>&lt;input type=&#39;text&#39; /&gt;</code>必须写斜杠或成对出现</p>
</li>
<li><p>在JSX中可以使用{}嵌入表达式</p>
<ul>
<li>有返回值就是表达式</li>
</ul>
</li>
<li><p>如果表达式是空值, Null, undefined, 布尔值, 不会显示</p>
</li>
<li><p>在JSX中, 属性可以直接在标签中设置</p>
<ul>
<li><p>class 需使用className代替</p>
</li>
<li><p>style中必须使用对象设置, 不能使用属性</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span>&#x27;<span class="attr">yellow</span>&#x27;&#125;&#125;&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> list  = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>相当于直接渲染列表中的所有元素</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>data.map(item =&gt; <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>好处:  </p>
<ol>
<li><p>降低API的复杂度</p>
</li>
<li><p>解决兼容问题</p>
</li>
<li><p>提升性能(减少DOM的不必要操作)</p>
</li>
</ol>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>当我们在JSX中显示数组时, 数组中每一个元素都需要一个唯一的KEY， 否则会显示警告</p>
</div>

<p>JSX比较元素是否发生改变是按照位置比较的，如果将一个新元素插入到数组前,则可能造成重复元素渲染, 为了解决这个问题, 可以自定义唯一KEY, 将比较规则改成用KEY比较</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#x27;3&#x27;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></div>

<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>尽量不要使用索引做KEY, 索引会跟着元素顺序改变, 做无用功. 唯一不同就是无警告</p>
</div>



<h3 id="React-项目"><a href="#React-项目" class="headerlink" title="React 项目"></a>React 项目</h3><hr>
<p>public&#x2F;index.html 是首页的模板; webpack会以index.html为模板生成index.html</p>
<p>src&#x2F;index.js 是js的入口文件</p>
<h4 id="手动准备"><a href="#手动准备" class="headerlink" title="手动准备"></a>手动准备</h4><p><code>npm init -y</code>初始化</p>
<p><code>npm install react react-dom react-scripts -S</code>下载依赖</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>需要使用<code>import ReactDOM from &#39;react-dom/client&#39;;</code>引入ReactDOM</p>
</div>



<p><code>npx react-scripts build</code>打包</p>
<p><code>npx react-scripts start</code>开发时测试</p>
<ul>
<li><p>这两个命令可以在packetage.json中加入’scripts’内置:</p>
<p><code>&quot;start&quot;: &quot;react-scripts start&quot;</code>  命令行中使用<code>npm start</code></p>
<p><code>&quot;build&quot;: &quot;react-scripts build&quot;</code>  命令行中使用<code>npm run build</code></p>
</li>
</ul>
<p>ESLint语法检查器: </p>
<ul>
<li><p>可以在packetage.json 中添加:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;extends&quot;: [</span><br><span class="line">        &quot;react-app&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>引入CSS<code>import &#39;./index.css&#39;</code></p>
<h4 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h4><h5 id="函数组件-推荐"><a href="#函数组件-推荐" class="headerlink" title="函数组件(推荐)"></a>函数组件(推荐)</h5><div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;<span class="comment">// 也可以使用箭头函数</span></span><br><span class="line">    retun &lt;div&gt;<span class="title class_">Hello</span>&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)<span class="comment">// 一般写在入口文件中</span></span><br></pre></td></tr></table></figure></div>

<h6 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h6><p>在React中事件需要通过元素的属性来设置，和原生Js不一样, 在React中事件的属性需要使用驼峰命名法</p>
<p><code>onclick -&gt; onClick</code></p>
<p><code>onchange -&gt; onChange</code></p>
<p>属性值不能直接执行代码:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">onClink = &#123;<span class="function">() =&gt;</span> &#123;<span class="title function_">alert</span>(<span class="string">&#x27;123&#x27;</span>)&#125;&#125; <span class="comment">// 正确</span></span><br><span class="line">oClink = &#123;clickHandler&#125; <span class="comment">//函数不需要加括号，若返回值为函数可加</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>事件对象</p>
<ul>
<li><p>React事件中同样会传递事件对象， 可以在响应函数中定义参数来接收事件对象</p>
</li>
<li><p>React事件对象不是原生的事件对象，是经过React包装过的事件对象</p>
</li>
</ul>
</li>
</ul>
<p>取消行为:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clickHandler</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    event.<span class="title function_">preventDefault</span>(); </span><br><span class="line">    <span class="comment">//取消默认行为(PS: 若放在&lt;a href=&#x27;#&#x27;&gt;中，则取消跳转)</span></span><br><span class="line">    event.<span class="title function_">stopPropagation</span>()</span><br><span class="line">    <span class="comment">//取消冒泡</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>动态传参</p>
<p>在组件间，父组件可以通过props(属性)向子组件传递数据(父传子)</p>
<ul>
<li>props(外部，父 -&gt; 子)是只读属性, 不能修改</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">LogItem</span> test=<span class="string">&#x27;123&#x27;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LogItem</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 可以在函数组件的形参中定义一个props，props指定所有传递的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.test&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>状态</p>
<p>在React中，当组件渲染完毕后，在修改组件中的变量，不会使组件重新渲染。因此必须重新渲染。</p>
<ul>
<li><p>state(自身)</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">LogItem</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCounter] = <span class="title function_">useState</span>(<span class="number">1</span>) </span><br><span class="line">    <span class="comment">// 该函数会返回一个数组，数组第一个元素是初始值，第二个是一个函数</span></span><br><span class="line">    <span class="comment">// 初始值只是用来显示，修改不会触发渲染</span></span><br><span class="line">    <span class="comment">// 函数通常命名为setXxxx, 使用函数可以修改count触发渲染</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>React会监控这个变量的变化，当state发生变化时，会自动触发组件的重新渲染</p>
</li>
<li><p>在函数组件中，我们需要通过钩子函数，获取state(useState)</p>
</li>
<li><p>State实际就是一个被React管理的变量</p>
</li>
<li><p>setXxxx只有在值与count不一样的时候才会渲染</p>
</li>
<li><p>当通过setState去修改一个state时，并不是修改当前state,是修改下一次渲染时的state时</p>
</li>
<li><p>setState()会触发组件的渲染，他是异步的，所以当调用setState需要用到旧值，可能出现错误。可以传递回调函数来修改state</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setCounter</span>(<span class="function"><span class="params">prevCounter</span> =&gt;</span> prevCounter + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 回调函数执行时，React会将最新的state值作为参数</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
</li>
</ul>
<div class="note-large notel-yellow"><div class="notel-title"><p>注意</p>
</div><div class="notel-content"><p>当useState为一个对象时，如果直接修改旧的State对象，对象地址不会改变，所以不会被渲染。可以使用浅拷贝</p>
 </div></div>

<p>PS: <code>setXxxx(&#123;...user, name:&#39;aaa&#39;&#125;)</code></p>
<ul>
<li><p>useRef()钩子函数</p>
<p>创建一个容器， 返回一个普通的JS对象，但是可以确保每次渲染都是同一个对象，减少对象的创建次数(当你需要一个对象不会因为渲染改变时使用)</p>
</li>
</ul>
<h5 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h5><p>必须继承React.Component</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="comment">// 类组件中，必须添加一个render()方法，且方法的返回值要是一个jsx</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>类组件的props是存储在实例对象中，可以直接通过实例对象访问<code>this.props</code></p>
</li>
<li><p>类组件的state是存储在对象的state属性中，可以直接通过<code>this.state</code>访问</p>
<ul>
<li><p>通过<code>this.setState()对其进行修改</code></p>
</li>
<li><p>当我们通过this.setState()修改state时，只会修改设置的属性(只限于直接存储state的值)</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">    <span class="attr">obj</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span>&#125; <span class="comment">// 没有直接存储在state，会被覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在类组件中，响应函数是以类的方法定义的</li>
</ul>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">clickHandler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">count</span>: prevState + <span class="number">1</span>    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>createRef钩子函数</p>
<p>与useRef相同，都是创建一个不会变化的JS容器</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>React Study</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-React-1</title>
    <url>/2023/03/07/JavaScript-React-1/</url>
    <content><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><hr>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制:"></a>限制:</h4><ul>
<li><p>只有一个参数的函数 参数 &#x3D;&gt; 返回值</p>
</li>
<li><p>多个参数使用括号 (a,b) &#x3D;&gt; 返回值</p>
</li>
<li><p>返回值必须是一个表达式</p>
</li>
<li><p>返回值是对象必须带括号</p>
</li>
<li><p>如需写语句，在后添加代码块</p>
</li>
</ul>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>隐含参数arguments-表示当前函数的实参 arguments.lenth 获取实参数。剩余参数…args</p>
</div>

<h4 id="特性"><a href="#特性" class="headerlink" title="特性:"></a>特性:</h4><ul>
<li><p>箭头函数中没有arguments，可以使用…args</p>
</li>
<li><p>箭头函数的this总是看外层作用域的this</p>
</li>
<li><p>箭头函数中的this无法通过call(), apply(), bind()修改</p>
</li>
<li><p>箭头函数无法作为构造函数，无法new</p>
</li>
</ul>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><hr>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>默认情况下，script标签中不能使用import语句，必须设置script的type属性为module</p>
</div>

<h4 id="导出"><a href="#导出" class="headerlink" title="导出:"></a>导出:</h4><ul>
<li><p>默认导出</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> xxx;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>一个模块里只有一个默认导出</p>
<ul>
<li><p>命名导出</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;a,b,c&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入:"></a>导入:</h4><ul>
<li><p>默认导入</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>导入默认模块时，变量名可以自主制定，无需使用模块中的变量名</p>
<ul>
<li><p>命名导入</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a,b,c&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><ul>
<li><p>构造函数</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>构造函数中，可以通过this来引用当前的对象</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><ul>
<li><p>严格模式</p>
<p>“use strict”</p>
<ol>
<li><p>类中的所有代码都会在严格模式下执行</p>
</li>
<li><p>函数的this不再是window,而是undefined</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> test = mc.<span class="property">fn</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ul>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>以方法形式调用时, this就是当前的实例。以函数形式调用, this是undefined</p>
</div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fn</span> = <span class="variable language_">this</span>.<span class="property">fn</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>) <span class="comment">//将fn方法的this绑定为当前实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以限制this绑定在自身</p>
<p>也可以使用箭头函数的形式调用，永远绑定为本身</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">   fn = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>在子类中重写父类构造函数时，应该在子类中第一时间调用父类构造函数，否则报错</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, age); <span class="comment">//调用父类构造函数，并且需要加入父类参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>动态属性</p>
<p>需要首先new一个实例才能使用</p>
</li>
<li><p>静态属性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">    <span class="comment">// 静态方法this不是实例对象而是当前类对象</span></span><br><span class="line">    <span class="keyword">static</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>可以直接使用<code>MyClass.name</code></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><hr>
<ul>
<li><p>map()</p>
<ol>
<li><p>可以根据原有的数组返回一个新数组</p>
</li>
<li><p>需要一个回调函数作为参数, 回调函数返回值会成为新数组中的元素</p>
<p>用法:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item+<span class="number">2</span></span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 第一个参数 当前元素</span></span><br><span class="line"><span class="comment">// 第二个参数 当前元素索引</span></span><br><span class="line"><span class="comment">// 第三个参数 当前数组</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p>filter()</p>
<p>过滤器</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">result = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>根据条件过滤元素</p>
<ul>
<li><p>find()</p>
<p>找第一个被过滤条件通过的元素</p>
</li>
</ul>
</li>
<li><p>reduce()</p>
<p>整合数组</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;&#125;, <span class="number">0</span>) </span><br><span class="line"><span class="comment">// 0的位置是定义第一次prev的值, prev 上一次合并后值, curr 当前值</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <tags>
        <tag>React Study</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-React-3</title>
    <url>/2023/03/09/JavaScript-React-3/</url>
    <content><![CDATA[<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><hr>
<p>父组件传递属性，需要在子组件获取才能使用:</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;<span class="string">`card <span class="subst">$&#123;props.className&#125;</span>`</span>&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<p>props.children 表示组件的标签体</p>
<p>useRef().current 表示当前的DOM</p>
<p>事件对象:</p>
<ul>
<li><p>event包含所有触发事件对象信息</p>
<div class="highlight-container" data-rel="Jsx"><figure class="iseeu highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">descChangeHandler</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/03/20/Linux/</url>
    <content><![CDATA[<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>当前目录下的所有内容(文件或文件夹)</p>
<p>默认目录home-家目录&#x2F;home&#x2F;‘username’</p>
<ol>
<li><p>命令参数[-a -l -h]</p>
<p>ls 目录 -查找目录下所有内容</p>
<p>-a-all 显示所有当前目录下所有内容(包括隐藏内容.)</p>
<p>-l-list 以列表方式加创建时间和权限组显示所有当前目录下所有内容</p>
<p>选项可以复合-al同时应用两类功能</p>
<p>-h 和-l混合使用 将内容容量以可读方式显示1KB,1MB等</p>
</li>
</ol>
<h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换工作目录Change Directory</p>
<p>cd [Linux路径] 无参数直接切换</p>
<p>不指定路径，直接回到home目录</p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>Print Work Directory</p>
<p>直接使用pwd打印当前工作目录路径 显示&#x2F;home&#x2F;xxx</p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>以根目录为起点，写出一个路径，以&#x2F;为起点</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>以当前目录为起点，写一个路径，不需要写&#x2F;</p>
<h4 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h4><p>.  表示当前目录，比如 cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内</p>
<p>.. 表示切换到上一级的某个目录</p>
<p>~ 表示HOME目录,比如cd ~即可退回HOME</p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>Make Directroy</p>
<p>创建目录，可以使用相对路径和绝对路径</p>
<p>makdir [-p] 路径</p>
<p>-p表示自动创建不存在的父目录</p>
<h3 id="ctrl-l-and-clear"><a href="#ctrl-l-and-clear" class="headerlink" title="ctrl+l and clear"></a>ctrl+l and clear</h3><p>清空屏幕</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建文件</p>
<p>touch 路径</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>查看文件内内容(全部打印)</p>
<p>cat 路径</p>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>查看文件内内容(可翻页–more–)</p>
<p>more 路径</p>
<p>退出翻页查看(键盘q)</p>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>copy</p>
<p>复制文件和文件夹</p>
<p>cp [-r] 参数1 参数2</p>
<p>-r 用于复制文件夹用，不输入即复制文件</p>
<p>参数1 表示被复制文件路径</p>
<p>参数2 表示要复制去的路径</p>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>服务器之间传递文件</p>
<p>scp [-r] 参数1 参数2</p>
<ul>
<li><p>-r 用于复制文件夹</p>
</li>
<li><p>参数 本机路径或远程目标路径</p>
</li>
</ul>
<p>scp -r &#x2F;export&#x2F;server&#x2F;jdk root@node2:&#x2F;export&#x2F;server&#x2F;</p>
<p>将本机上的jdk文件夹，以root身份复制到node2的指定路径中</p>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>move</p>
<p>移动文件夹和文件，改名</p>
<p>mv 参数1 参数2</p>
<p>参数与cp同</p>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>remove</p>
<p>rm [-r -f] 参数1——n</p>
<p>删除文件和文件夹</p>
<p>-r 用于删除文件夹</p>
<p>-f 表示force 强制删除(不会弹出提示确认信息)</p>
<ul>
<li>普通用户不会弹出，root用户会弹出</li>
</ul>
<p>参数表示要删除的文件或文件夹路径空格隔开，可一起删除</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符*"></a>通配符*</h4><p>匹配任意内容</p>
<p>test* 匹配任何test开头的内容</p>
<p>*test * 匹配任何包含test的内容</p>
<p>*test 匹配test结尾的内容</p>
<p>rm -rf &#x2F;* 强制删除根目录下所有内容</p>
<h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>查看命令的程序文件的路径</p>
<p>which [命令]</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>搜索指定文件</p>
<p>find 起始路径 -name ‘查找文件名’</p>
<p>root用户全盘搜索</p>
<p>find 起始路径 -size +|-n [kMG]</p>
<ul>
<li><p>+,-表示大于和小于</p>
</li>
<li><p>n表示大小数字</p>
</li>
<li><p>kMG表示大小单位</p>
</li>
</ul>
<p>find &#x2F; -size -10k</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>从文件中通过关键字过滤文件行</p>
<p>grep [-n] ’关键字‘ 文件路径</p>
<h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>统计文件的行数</p>
<p>wc [-c  -m -l -w] 文件路径(不加参数，显示行数，单词数，字节数，文件名)</p>
<p>-c 统计bytes数</p>
<p>-m 统计字符数</p>
<p>-l 统计行数</p>
<p>-w 统计单词数</p>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符(|)"></a>管道符(|)</h3><p>将管道符左边的结果，作为右边的输入</p>
<ul>
<li><p>cat test.txt | grep x</p>
</li>
<li><p>ls -lh &#x2F;usr | wc -l</p>
</li>
<li><p>cat test.txt | grep x | grep xx</p>
</li>
</ul>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>在命令行中输出指定内容</p>
<p>echo ‘输出的内容’</p>
<p>echo &#96;&#96;(反引号内输入命令) 输出命令结果 </p>
<h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><p>[&gt;] 将左侧命令的结果，覆盖写入到符号右侧</p>
<ul>
<li>echo ‘hello’ &gt; test.txt</li>
</ul>
<p>[&gt;&gt;] 将左侧命令的结果，追加写入符号右侧</p>
<ul>
<li>ls &#x2F; &gt; test.txt</li>
</ul>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>可以查看文件尾部内容，跟踪文件最新更改</p>
<p>tail [-f -num] 路径</p>
<p>-f 表示持续跟踪</p>
<p>-num 表示查看尾部多少行，不填默认10行</p>
<ul>
<li>tail -5 test.txt</li>
</ul>
<h3 id="vi-x2F-vim"><a href="#vi-x2F-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h3><p>Linux中最经典的文本编辑器</p>
<p>vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，还具有shell程序编辑的功能，可以不同颜色的字体来辨别语法的正确性</p>
<ol>
<li><p>命令模式 (Command mode)</p>
<p>所敲的按键编辑器都理解成命令,此模式下,不能自由进行文本编辑</p>
</li>
<li><p>输入模式(Insert mode)</p>
<p>此模式下，可以对文件内容进行自由编辑</p>
</li>
<li><p>底线命令模式(Last line mode)</p>
<p>以:开始，通常用于文件的保存和退出</p>
</li>
</ol>
<p>vim 文件路径</p>
<ul>
<li><p>如果文件存在打开，不存在则创建</p>
</li>
<li><p>从命令模式点击i进入输入模式</p>
</li>
<li><p>从输入模式使用esc退回命令模式</p>
</li>
<li><p>命令模式下按:进入底线命令模式</p>
<ul>
<li>wq w保存 q退出</li>
</ul>
</li>
</ul>
<p>命令模式命令</p>
<blockquote>
<p>$移动到行结尾</p>
<p>0移动到行开头</p>
<p>&#x2F;进入搜索模式</p>
<p>n向下搜索</p>
<p>N向上搜索</p>
<p>yy复制当前行</p>
<p>p粘贴</p>
<p>dd删除当前行</p>
<p>ndd删除当前行和下面的n行</p>
<p>u撤销修改</p>
<p>ctrl+r反向撤销修改</p>
<p>gg跳到首行</p>
<p>G跳到最后一行</p>
<p>dG从当前行向下全部删除</p>
<p>dgg向上全部删除</p>
<p>d$从光标开始删除到本行行尾</p>
<p>d0从光标开始删除到本行行首</p>
</blockquote>
<p>底线命令模式命令</p>
<blockquote>
<p>:wq 保存退出</p>
<p>:q! 强制退出</p>
<p>:set nu 显示行号</p>
<p>:set paste设置粘贴模式</p>
</blockquote>
<h3 id="root-超级管理员"><a href="#root-超级管理员" class="headerlink" title="root(超级管理员)"></a>root(超级管理员)</h3><p>拥有最大的系统操作权限</p>
<h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>su -  默认切换root</p>
<p>su-root 密码 切换root管理员(-是为了在登录时加载环境变量)</p>
<p>exit 回退</p>
<p>root管理员切换其他账号不要密码</p>
<h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>临时以root身份执行命令</p>
<p>sudo 其他命令</p>
<p>只有认证的用户才能使用</p>
<ul>
<li><p>为普通用户配置认证</p>
<ul>
<li><p>切换到root用户，执行visudo命令打开&#x2F;etc&#x2F;sudoers</p>
</li>
<li><p>在文件最后添加:</p>
<p><code>intyou ALL=(ALL)     NOPASSWD:ALL</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="用户，用户组"><a href="#用户，用户组" class="headerlink" title="用户，用户组"></a>用户，用户组</h3><p>以下命令使用root用户执行</p>
<h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><p>groupadd 用户组名 创建用户组</p>
<p>groupdel 用户组名 删除用户组</p>
<h4 id="用户管理-Ubuntu"><a href="#用户管理-Ubuntu" class="headerlink" title="用户管理(Ubuntu)"></a>用户管理(Ubuntu)</h4><p>useradd [-g -d] 用户名</p>
<ul>
<li><p>-g 指定用户的组，不指定，会创建同名组并自动加入，指定组需要已存在， 如已知存在同名组，必须使用-g</p>
</li>
<li><p>-d指定用户HOME路径， 不指定， HOME目录默认在: &#x2F;home&#x2F;用户名</p>
</li>
<li><p>-m创建家目录</p>
</li>
</ul>
<p>userdel [-r] 用户名</p>
<ul>
<li>-r 删除用户的HOME目录，不使用, HOME目录保留</li>
</ul>
<p>id 用户名</p>
<ul>
<li>查看用户的用户组</li>
</ul>
<p>usermod -aG</p>
<p>将指定用户加入指定用户组</p>
<p>getent</p>
<p>getent passwd 查看当前系统中有哪些用户</p>
<p>getent group 查看当前系统中有哪些用户组</p>
<h3 id="认知权限信息"><a href="#认知权限信息" class="headerlink" title="认知权限信息"></a>认知权限信息</h3><p>ls -l 输出的信息分析</p>
<p>drwxr-xr-x  intyou intyou</p>
<p>drwxr-xr-x - 表示权限管控细节</p>
<p>-代表无</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-03-21-18-03-51-image.png"
                     
                ></p>
<p>第一块 ‘-‘表示文件 ‘d’表示文件夹 ‘l’表示软链接</p>
<p>除去第一块:</p>
<ul>
<li><p>前三块代表所属用户权限</p>
</li>
<li><p>中三块代表所属用户组权限</p>
</li>
<li><p>后三块代表其他用户权限</p>
</li>
</ul>
<p>r 读权限</p>
<p>w写权限</p>
<p>x执行权限</p>
<h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>修改文件，文件夹的权限信息</p>
<p>只有文件文件夹的所属用户或root用户可以修改</p>
<p>chmod [-R] 权限 文件和文件夹</p>
<ul>
<li>-R 对文件夹内的全部内容应用同样的操作</li>
</ul>
<p><code>chomd u=rwx,g=rx,o=x hello.txt</code>将文件权限修改为rwxr-x–x</p>
<p>u表示所属用户权限，g表示group组权限，o表示other其他用户权限</p>
<h4 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h4><p>权限的数字序号</p>
<p>权限可以用三位数字来代表，第一位数字表示用户权限，第二位表示用户组权限，第三位表示其他用户权限</p>
<p>命令从右到左依次增加</p>
<p>0：— 1：–x 2：-w-3：-wx 4：r– 5：r-x 6：rw- 7：rwx</p>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>只能root用户执行</p>
<p>修改文件和文件夹的所属用户和用户组</p>
<p>chown [-R] [用户] [:] [用户组] 文件或文件夹</p>
<p>chown root hello.txt 将hello.txt所属用户修改为root</p>
<p>chown :root hello.txt 将hello.txt所属用户组修改为root</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><h4 id="ctrl-c-强制停止"><a href="#ctrl-c-强制停止" class="headerlink" title="ctrl+c 强制停止"></a>ctrl+c 强制停止</h4><h4 id="ctrl-d-退出或登录"><a href="#ctrl-d-退出或登录" class="headerlink" title="ctrl+d 退出或登录"></a>ctrl+d 退出或登录</h4><ul>
<li>不能用于退出vi&#x2F;vim</li>
</ul>
<h4 id="历史命令搜索"><a href="#历史命令搜索" class="headerlink" title="历史命令搜索"></a>历史命令搜索</h4><ul>
<li><p>history</p>
<p>history | grep ‘xxx’</p>
</li>
<li><p>!命令前缀 自动执行上一次匹配前缀的命令</p>
<p>python</p>
<p>!p</p>
</li>
<li><p>ctrl+r 输入内容去匹配历史命令</p>
</li>
</ul>
<h3 id="centos-下载包"><a href="#centos-下载包" class="headerlink" title="centos 下载包"></a>centos 下载包</h3><h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><p>yum [-y] [install | remove | search] 软件名称</p>
<ul>
<li><p>-y 自动确定， 无需手动确认安装或卸载过程</p>
</li>
<li><p>install 安装</p>
</li>
<li><p>remove 卸载</p>
</li>
<li><p>search 搜索</p>
</li>
</ul>
<p>yum命令需要root指令</p>
<h3 id="ubuntu下载包"><a href="#ubuntu下载包" class="headerlink" title="ubuntu下载包"></a>ubuntu下载包</h3><h4 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h4><p>apt [-y] [install | remove | search] 软件名称</p>
<p>与centos相同</p>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>控制软件(内置或第三方)启动，停止，开机自启</p>
<p>systemctl start | stop | status | enable | disable 服务名</p>
<p>enable&#x2F;disable 打开、关闭开机自启</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>在系统中创建软链接，可以将文件和文件夹链接到其他位置(快捷方式)</p>
<p>ln -s 参数1 参数2</p>
<p>-s 创建软链接</p>
<p>参数1 被链接的文件或文件夹</p>
<p>参数2 要链接去的目的地</p>
<p><code>ln -s /etc/yum.conf ~/yum.conf</code></p>
<h3 id="date"><a href="#date" class="headerlink" title="date"></a>date</h3><p>date [-d] [+格式化字符串]</p>
<ul>
<li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p>
<p>支持 year month day hour minute second</p>
<p>date -d ‘+1 day’ ‘+%Y-%m-%d’</p>
</li>
<li><p>格式化字符串</p>
<ul>
<li><p>%Y 年</p>
</li>
<li><p>%y 年份后两位数字(00,99)</p>
</li>
<li><p>%m 月份</p>
</li>
<li><p>%d 日</p>
</li>
<li><p>%H 小时</p>
</li>
<li><p>%M 分钟</p>
</li>
<li><p>%S 秒</p>
</li>
<li><p>%s 自1970-01-01 00:00:00 到现在的秒数</p>
</li>
</ul>
<p>date ‘+%Y-%m-%d %H:%M:%S’</p>
</li>
</ul>
<h4 id="修改linux时区-东八区"><a href="#修改linux时区-东八区" class="headerlink" title="修改linux时区(东八区)"></a>修改linux时区(东八区)</h4><p>root权限</p>
<p>rm -f &#x2F;etc&#x2F;localtime</p>
<p>sudo ln -s &#x2F;user&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</p>
<h4 id="ntp程序"><a href="#ntp程序" class="headerlink" title="ntp程序"></a>ntp程序</h4><p>联网自动校准系统时间</p>
<p>需要使用apt下载</p>
<p>使用systemctl enable ntp 开机自启</p>
<p>手动校准 ntpdate -u ntp.aliyun.com</p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>查看ip信息</p>
<h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h3><p>查看主机名</p>
<ul>
<li>hostname set-hostname 名字 修改主机名</li>
</ul>
<h3 id="在linux中固定ip地址"><a href="#在linux中固定ip地址" class="headerlink" title="在linux中固定ip地址"></a>在linux中固定ip地址</h3><p>在ubuntu22.04中应找到&#x2F;etc&#x2F;netplan中的yaml文件修改</p>
<blockquote>
<p><a class="link"   href="https://www.cnblogs.com/liujiaxin2018/p/16287463.html" >ubuntu 22.04如何配置静态IP、网关、DNS - 小鲨鱼2018 - 博客园 (cnblogs.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>&#96;</p>
</blockquote>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>检测指定网络服务器是否可联通状态</p>
<p>ping [-c num] ip或主机名</p>
<p>-c 检查的次数 不使用，将无限次</p>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>可以在命令行内下载网络文件</p>
<p>wget [-b] url</p>
<p>-b 后台下载</p>
<p>参数: url 下载链接</p>
<p>不管成功下载或者不成功，都会创建文件</p>
<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>可以发送网络请求 下载文件 获取网站状态</p>
<p>curl [-O] url</p>
<p>-O 用于下载文件，当url是下载链接时，可以使用此选项保存文件</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h4 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h4><ul>
<li><p>netstat</p>
<p>需要apt安装</p>
<p>netstat -anp|grep 端口号</p>
</li>
<li><p>nmap</p>
<p>需要apt安装</p>
<p>nmap 端口</p>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>ps [-e -f]</p>
<ul>
<li><p>-e 显示全部的进程</p>
</li>
<li><p>-f 已完全格式化的形式展示信息</p>
</li>
</ul>
<p>固定用法ps -ef 列出全部进程的全部信息</p>
<p>例: ps -ef | grep tail</p>
<h4 id="关闭进程"><a href="#关闭进程" class="headerlink" title="关闭进程"></a>关闭进程</h4><p>kill [-9] 进程ID</p>
<p>-9 表示强制关闭进程</p>
<h3 id="查看系统占用"><a href="#查看系统占用" class="headerlink" title="查看系统占用"></a>查看系统占用</h3><p>top 查看cpu占用</p>
<ul>
<li><p>第一行: 命令名称 当前系统时间 up 6 min: 启动了6分钟 2users: 2个用户登录 load average: 0.06 0.17 0.13   1 5 15分钟负载</p>
</li>
<li><p>第二行: Task 进程数  running: 正在运行进程数 sleeping: 进程睡眠数 stopped停止进程数  zombie 僵尸进程数</p>
</li>
<li><p>第三行: %cpu cpu使用率 us 用户cpu使用率 sy 系统cpu使用率  ni高优先级进程占用cpu时间百分比 id空闲cpu率  wa IO等待cpu占用率  hi  cpu硬件中断率  si CPU软件中断率   st 强制等待占用cpu率</p>
</li>
<li><p>第四行: kib Mem 物理内存  total总量  free空闲  used 使用  buff&#x2F;cache buff和cache占用 kibSwap  虚拟内存(交换空间)</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-03-22-19-26-29-image.png"
                     
                ></p>
<p>选项:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-03-22-19-28-00-image.png"
                     
                ></p>
<p>交互式选项:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-03-22-19-31-28-image.png"
                     
                ></p>
<h3 id="磁盘信息监控"><a href="#磁盘信息监控" class="headerlink" title="磁盘信息监控"></a>磁盘信息监控</h3><p>查看硬盘使用情况</p>
<p>df [-h]</p>
<ul>
<li>-h 以更加人性化的单位显示</li>
</ul>
<p>iostat [-x] [num1][num2]</p>
<p>需要下载包</p>
<ul>
<li><p>-x 显示更多信息</p>
</li>
<li><p>num1 数字 刷新时间，num2 数字 刷新几次</p>
</li>
<li><p>tps 该设备每秒的传输次数，’一次传输’&#x3D;’一次I&#x2F;O请求’。多个逻辑请求可能会被合并为”一次I&#x2F;O请求”</p>
</li>
<li><p>rKB&#x2F;s 每秒发送到设备的读取请求数  wKB&#x2F;s 每秒发送到设备的写入请求数 %util 磁盘利用率</p>
</li>
</ul>
<h3 id="网络状态监控"><a href="#网络状态监控" class="headerlink" title="网络状态监控"></a>网络状态监控</h3><p>sar -n DEV num1 num2</p>
<p>需要下载包</p>
<ul>
<li><p>-n 查看网络</p>
</li>
<li><p>DEV 查看网络接口</p>
</li>
</ul>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>简化程序执行路径</p>
<p>env 查看当前系统中记录的环境变量</p>
<h4 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h4><p>$获取变量的值</p>
<blockquote>
<p>echo $PATH</p>
<p>echo ${PATH}ABC</p>
</blockquote>
<h4 id="自行设置环境变量"><a href="#自行设置环境变量" class="headerlink" title="自行设置环境变量"></a>自行设置环境变量</h4><ul>
<li><p>临时设置 export 变量名 &#x3D; 变量值</p>
</li>
<li><p>永久生效</p>
<ul>
<li><p>针对当前用户生效，配置在当前用户的: ~&#x2F;.bashrc文件中</p>
</li>
<li><p>针对所有用户生效， 配置在系统的: &#x2F;etc&#x2F;profile文件中</p>
</li>
<li><p>并通过语法: source 配置文件, 进行立刻生效</p>
</li>
</ul>
</li>
</ul>
<h4 id="自定义环境变量PATH"><a href="#自定义环境变量PATH" class="headerlink" title="自定义环境变量PATH"></a>自定义环境变量PATH</h4><p>export PATH&#x3D;$PATH: 路径</p>
<h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><h5 id="tar-gz"><a href="#tar-gz" class="headerlink" title=".tar  .gz"></a>.tar  .gz</h5><p>gzip体积压缩格式.tar.gz</p>
<p>tar [-c -v -x -f -z -C] 参数1—n</p>
<ul>
<li><p>-c 创建压缩文件</p>
</li>
<li><p>-v 显示压缩，解压过程</p>
</li>
<li><p>-x 解压模式</p>
</li>
<li><p>-f 要创建的文件，或要解压的文件，必须在所有选项中处于最后一个</p>
</li>
<li><p>-z gzip模式 不使用就是普通tarball格式 一般处于第一个</p>
</li>
<li><p>-C 选择解压的目的地, 单独使用</p>
</li>
</ul>
<p>压缩:</p>
<p>tar -cvf test.tar 1.txt 2.txt</p>
<p>将1.txt 2.txt压缩到test.tar</p>
<p>解压:</p>
<p>tar -xvf test.tar -C 解压路径</p>
<p>将test.tar 解压到解压路径</p>
<h5 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h5><p>压缩:</p>
<p>zip [-r] 参数1—n</p>
<ul>
<li>被压缩的包含文件夹的时候</li>
</ul>
<p>解压:</p>
<p>unzip [-d] 参数</p>
<ul>
<li>-d 指定解压路径</li>
</ul>
]]></content>
      <tags>
        <tag>Linux Study</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2023/04/12/MySQL/</url>
    <content><![CDATA[<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><hr>
<blockquote>
<p>结构化查询语言，用于存取，查询，更新数据以及管理关系型数据库系统</p>
</blockquote>
<ul>
<li><p>在不同的数据库产品中遵循SQL的通用规范，但是也对SQL有一些不同的改进，形成了一些数据库的专有指令</p>
<ul>
<li><p>MySQL: limit</p>
</li>
<li><p>SQLServer: top</p>
</li>
<li><p>Oracle: rownum</p>
</li>
</ul>
</li>
</ul>
<h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><hr>
<blockquote>
<p>根据SQL指令完成的数据库操作的不同，可以将SQL指令分类</p>
</blockquote>
<ul>
<li><p>DDL Data Definition Language 数据定义语言</p>
<ul>
<li>用于完成对数据库对象(数据库，数据表，视图，索引等)的创建，删除，修改</li>
</ul>
</li>
<li><p>DML Data Manipulation Language 数据操作语言</p>
<ul>
<li>用于完成对数据表中的数据的添加，删除，修改操作</li>
</ul>
</li>
<li><p>DQL Data Query Language 数据查询语言</p>
<ul>
<li>用于将数据表中的数据查询出来</li>
</ul>
</li>
<li><p>DCL Data Control Language 数据控制语言</p>
<ul>
<li>用于完成事务管理等控制性操作</li>
</ul>
</li>
</ul>
<h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><hr>
<blockquote>
<p>在MySQL Command Line Client 或者 navicat 等工具中都能编写SQL指令</p>
</blockquote>
<ul>
<li><p>SQL 指令不区分大小写</p>
</li>
<li><p>每条SQL表达式结束之久都以<code>;</code>结束</p>
</li>
<li><p>SQL 关键字之间以空格进行分割</p>
</li>
<li><p>SQL 之间可以不限制换行(可以有空格的地方就可以换行)</p>
</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><hr>
<h4 id="DDL-数据库操作"><a href="#DDL-数据库操作" class="headerlink" title="DDL-数据库操作"></a>DDL-数据库操作</h4><hr>
<blockquote>
<p>使用DDL语句可以创建，查询，修改，删除数据库</p>
</blockquote>
<h5 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 显示当前数据库列表</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line">## 显示此数据库创建<span class="keyword">SQL</span>指令</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 创建数据库 dbName表示创建的数据库名称</span><br><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 创建数据库，防止数据库存在报错,当不存在时创建</span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 在创建数据库的同时指定数据库的字符集(编码格式,utf8可选)</span><br><span class="line"><span class="keyword">create</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span> <span class="type">character</span> <span class="keyword">set</span> <span class="operator">&lt;</span>utf8<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 修改数据库的字符集</span><br><span class="line"><span class="keyword">alter</span> database <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span> <span class="type">character</span> <span class="keyword">set</span> <span class="operator">&lt;</span>utf8<span class="operator">&gt;</span>; # utf8 gbk</span><br></pre></td></tr></table></figure></div>

<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 删除数据库,防止数据库不存在报错</span><br><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="使用-x2F-切换数据库"><a href="#使用-x2F-切换数据库" class="headerlink" title="使用&#x2F;切换数据库"></a>使用&#x2F;切换数据库</h5><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">use <span class="operator">&lt;</span>dbName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>创建数据表</p>
<blockquote>
<p>数据表实际上就是一个二位的表格，是由多列组成，表格的每一列时表格的一个字段</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="operator">&lt;</span>dbTableName<span class="operator">&gt;</span>(</span><br><span class="line">    <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span> <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>, # 格式，下为例子</span><br><span class="line">    T_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    T_gender <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    T_age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    T_tel <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查询数据表列</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> tables; </span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查询表结构</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除数据表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 删除数据表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 当数据表存在时删除数据表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改数据表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 修改表名</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> rename <span class="keyword">to</span> <span class="operator">&lt;</span>newTableName<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 数据表也是有字符集的，默认字符集与数据库一致</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="type">character</span> <span class="keyword">set</span> <span class="operator">&lt;</span>utf8<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 添加字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">add</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="type">varchar</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">## 修改字段的列表和类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> change <span class="operator">&lt;</span>oldColumnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>newColumnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 只修改字段类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> modify <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>newType<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 删除字段</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h3><hr>
<ul>
<li><p>数值类型</p>
<blockquote>
<p>tinyint smallint mediumint int&#x2F;integer bigint float double decimal</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">  stock tinyint  </span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</blockquote>
</li>
<li><p>字符类型</p>
</li>
<li><p>日期类型</p>
<blockquote>
<p>在MySQL数据库中，我们可以使用字符串来存储时间，但是如果我们需要基于时间字段进行查询操作(查询在某个时间段内的数据)就不变于查询实现</p>
</blockquote>
</li>
</ul>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><hr>
<blockquote>
<p>在创建数据表的时候，指定的对数据表的列的数据限制性的要求(对表的列中的数据进行限制)</p>
</blockquote>
<ul>
<li><p>保证数据有效性</p>
</li>
<li><p>保证数据完整性</p>
</li>
<li><p>保证数据正确性</p>
</li>
</ul>
<h4 id="字段常见的约束"><a href="#字段常见的约束" class="headerlink" title="字段常见的约束"></a>字段常见的约束</h4><hr>
<ul>
<li><p>非空约束</p>
<blockquote>
<p>限制此列的值必须提供，不能null</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">    a <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> # 添加<span class="keyword">not</span> <span class="keyword">null</span>字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>唯一约束</p>
<blockquote>
<p>在表中的多条数据，此列的值不能重复</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">    a <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span> # 添加<span class="keyword">unique</span>字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>主键约束</p>
<blockquote>
<p>非空+唯一，能够唯一标识数据表中的一条数据</p>
<p>主键 ——数据表中记录的唯一标识，在一张表中只能有一个主键(主键可以是一列，也可以是多个列的集合)</p>
<p>当一个字段声明为主键之后，添加数据时</p>
<ul>
<li><p>此字段数据不能为空</p>
</li>
<li><p>此字段数据不能重复</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>创建表时添加主键约束</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">    a <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">primary</span> key # 添加<span class="keyword">primary</span> key字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>或</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> books(</span><br><span class="line">    a <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    b <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(a) # 最后定义</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除数据表主键约束</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建表之后添加主键约束</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> modify <span class="operator">&lt;</span>cloumnName<span class="operator">&gt;</span> <span class="operator">&lt;</span>type<span class="operator">&gt;</span> <span class="keyword">primary</span> key</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>主键自增长</p>
<blockquote>
<p>在我们创建一张数据表时，如果数据表中有列可以作为主键(例如: 学生表的学号)我们可以直接使这个列为主键；当有些数据表中没有合适的列作为主键时，我们可以额外定义一个与记录本身无关的列(ID)作为主键，此列无具体含义主要用于表示一条记录，在MySQL中我们可以将此列定义为int，同时设置自动增长，当我们向数据表中新增一条记录时，无需提供ID列的值，它会自动生成</p>
</blockquote>
<ul>
<li><p>定义主键自动增长</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> types(</span><br><span class="line">    # 关键词添加 auto_increment,一定要在主键中，字段名自定义</span><br><span class="line">    <span class="operator">&lt;</span>type_id<span class="operator">&gt;</span> <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    type_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    type_remark <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>注意：自动增长从1开始，每添加一条记录，自动的增长的列会自+1，当我们把某条记录删除之后再添加数据，自动增长的数据也不会重复生成(自动增长只保证唯一性，不保证连续性)</p>
</li>
</ul>
</li>
<li><p>联合主键</p>
<blockquote>
<p>将数据表中的多列组合在一起设置为表的主键</p>
</blockquote>
<ul>
<li><p>定义联合主键</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> grades(</span><br><span class="line">    stu_num <span class="type">char</span>(<span class="number">8</span>),</span><br><span class="line">    course_id <span class="type">int</span>,</span><br><span class="line">    score <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(stu_num, course_id) # 添加联合主键</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>注意：在实际企业项目的数据库设计中，联合主键使用的频率并不高；当一个数据表中没有明确的字段可以作为主键时，我们可以额外添加一个ID字段作为主键</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>外键约束：建立不同表之间的关联关系</p>
</li>
</ul>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><hr>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line"> T_num <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">primary</span> key,</span><br><span class="line"> T_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> T_gender <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> T_age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> T_tel <span class="type">char</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><hr>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 像数据表中指定的列添加数据(不允许为空的列必须提供数据)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>(columnName, columnName ...) </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">value</span> (value1, value2 ...);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 数据表名后的字段名列表顺序可以不与表中一致</span><br><span class="line">## 但是<span class="keyword">value</span>中值的顺序必须与表名后的字段名顺序对应</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(T_num, T_name, T_gender, T_age, T_tel) </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="number">8</span>, <span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line">## 当要向表中的所有列添加数据时，数据表名后面的字段列表可以省略，</span><br><span class="line">## 但是<span class="keyword">value</span>中的值的顺序要与数据表定义的字段顺序保持一致</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;1234&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="number">8</span>, <span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><hr>
<blockquote>
<p>从数据表中删除满足特定条件(所有)的数据</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> [<span class="keyword">where</span> conditions];</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><hr>
<blockquote>
<p>对数据表中以及添加的记录进行修改</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">set</span> columnName<span class="operator">=</span><span class="keyword">value</span>, columnName1<span class="operator">=</span>value2...</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> [<span class="keyword">where</span> conditions]</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><hr>
<blockquote>
<p>从数据表中提取满足特定条件的记录</p>
<ul>
<li><p>单表查询</p>
</li>
<li><p>多表联合查询</p>
</li>
</ul>
</blockquote>
<h4 id="查询基础"><a href="#查询基础" class="headerlink" title="查询基础"></a>查询基础</h4><hr>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## <span class="keyword">select</span> 关键字后指定要显示查询到的记录的那些列</span><br><span class="line"><span class="keyword">select</span> columnName1[,columnName2,...] <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line">## 查询所有列</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span>; # 不建议使用</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h4><hr>
<blockquote>
<p>在删除，修改及查询的语句后都可以添加where子句(条件)，用于筛选满足条件的数据进行操作</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> conditions</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">set</span> ... <span class="keyword">where</span> conditions</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> conditions</span><br></pre></td></tr></table></figure></div>

<h4 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h4><hr>
<blockquote>
<p>在 where 子句中，可以将多个条件通过逻辑预算符进行连接，通过多个条件来筛选要操作的数据</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## <span class="keyword">and</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;=</span><span class="keyword">value</span> <span class="keyword">and</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;=</span><span class="keyword">value</span></span><br><span class="line"></span><br><span class="line">## <span class="keyword">or</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;=</span><span class="keyword">value</span> <span class="keyword">or</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;=</span><span class="keyword">value</span></span><br><span class="line"></span><br><span class="line">## <span class="keyword">not</span> <span class="keyword">between</span> ... <span class="keyword">and</span> ...</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">not</span> <span class="keyword">between</span> a <span class="keyword">and</span> b</span><br></pre></td></tr></table></figure></div>

<h4 id="LIKE-子句"><a href="#LIKE-子句" class="headerlink" title="LIKE 子句"></a>LIKE 子句</h4><hr>
<blockquote>
<p>在 where 子句的条件中，我们可以使用like关键字来实现模糊查询</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">like</span> <span class="string">&#x27;reg&#x27;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>在like关键字后的reg表达式中，为正则表达式的使用</p>
<ul>
<li><p>% 表示任意多个字符【%o%包含字母o】</p>
</li>
<li><p>_表示任意一个字符 【_o% 第二个字母为o】</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对查询结果的处理"><a href="#对查询结果的处理" class="headerlink" title="对查询结果的处理"></a>对查询结果的处理</h3><hr>
<h4 id="设置查询的列"><a href="#设置查询的列" class="headerlink" title="设置查询的列"></a>设置查询的列</h4><blockquote>
<p>声明显示查询结果的指定列</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> columnName1,columnName2... </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="operator">&gt;</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></div>

<h4 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h4><blockquote>
<p>对从数据表中查询的记录的列进行运算之后显示出来</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> columnName1,x <span class="operator">-</span> columnName2... <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="字段别名"><a href="#字段别名" class="headerlink" title="字段别名"></a>字段别名</h4><blockquote>
<p>我们可以为查询结果的列名，去一个语义性更强的别名</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">as</span> <span class="operator">&lt;</span>xxx<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="消除重复行"><a href="#消除重复行" class="headerlink" title="消除重复行"></a>消除重复行</h4><blockquote>
<p>从查询的结果中将重复的记录消除</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> # 关键字<span class="keyword">distinct</span></span><br></pre></td></tr></table></figure></div>

<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><blockquote>
<p>将查询到的结果按照一定规则升序&#x2F;降序排列</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 单字段排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> <span class="keyword">where</span> conditions </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span> # 关键字段 <span class="keyword">order</span> <span class="keyword">by</span> ... <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>order by columnName 表示将查询结果按照指定的列排序(置于where条件后)</p>
</li>
<li><p>asc 升序(默认)</p>
</li>
<li><p>desc 降序</p>
</li>
</ul>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 多字段排序，先满足第一个排序规则，后满足下一个</span><br><span class="line">... <span class="keyword">by</span> <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">asc</span>, <span class="operator">&lt;</span>columnName<span class="operator">&gt;</span> <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><hr>
<blockquote>
<p>SQL 中提供了一些可以对查询记录的列进行计算的函数</p>
</blockquote>
<ul>
<li><p><code>count()</code> 统计函数，统计满足条件的指定字段值的个数(记录数)</p>
</li>
<li><p><code>max()</code> 获取最大值</p>
</li>
<li><p><code>min()</code> 获取最小值</p>
</li>
<li><p><code>sum()</code> 计算和，指定列的总和</p>
</li>
<li><p><code>avg()</code> 求平均值</p>
</li>
</ul>
<h3 id="日期函数-和-字符串函数"><a href="#日期函数-和-字符串函数" class="headerlink" title="日期函数  和 字符串函数"></a>日期函数  和 字符串函数</h3><hr>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><blockquote>
<p>当我们向日期类型的列表添加数据时，可以通过字符串类型赋值(字符串的格式必须为yyyy-MM-dd hh:mm:ss)</p>
<p>如果我们想要获取当前系统时间到日期类型的列，可以使用<code>now()</code>或<code>sysdate()</code></p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,now());</span><br></pre></td></tr></table></figure></div>

<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><blockquote>
<p>通过SQL指令对字符串进行处理</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 拼接字符串 concat</span><br><span class="line"><span class="keyword">select</span> concat(xxx,<span class="string">&#x27;-&#x27;</span>,aaa) <span class="keyword">from</span> T;</span><br><span class="line"></span><br><span class="line">## 将字段的值转换成大写</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">upper</span>(xxx) <span class="keyword">from</span> T;</span><br><span class="line"></span><br><span class="line">## 将字段的值转换为小写</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">lower</span>(xxx) <span class="keyword">from</span> T;</span><br><span class="line"></span><br><span class="line">## 从指定列中截取部分显示 <span class="keyword">start</span>从<span class="number">1</span>开始,len是长度</span><br><span class="line"><span class="keyword">select</span> xxx, <span class="built_in">substring</span>(xxxx,<span class="keyword">start</span>,len) <span class="keyword">from</span> T;</span><br></pre></td></tr></table></figure></div>

<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><hr>
<blockquote>
<p>将数据表中的列记录按照指定的列进行分组</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 分组字段<span class="operator">/</span>聚合函数 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">group</span> <span class="keyword">by</span> 分组字段 [<span class="keyword">having</span> 条件] [<span class="keyword">order</span> <span class="keyword">by</span> 排序字段]</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>select 后通常显示分组字段和聚合函数</p>
</li>
<li><p>语句执行顺序：</p>
<ol>
<li><p>先根据where条件从数据库查询记录</p>
</li>
<li><p>group by对查询记录进行分组</p>
</li>
<li><p>执行having对分组后的数据进行筛选</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><hr>
<blockquote>
<p>当数据表中的记录比较多的时候，如果一次性全部查询出来显示给用户，用户的可读性、体验性就不太好，因此我们可以将这些数据分页进行展示</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> ... <span class="keyword">where</span> ... limit param1,param2</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>param1 int 表示获取查询语句的结果中的第一条数据的索引(索引从0开始)</p>
</li>
<li><p>param2 int 表示获取的查询记录的条数(如果剩下的数据条数&lt;param2,则返回剩下的条目)</p>
</li>
</ul>
</li>
<li><p>案例：对数据表中的学生信息进行分页显示，总共有10条数据，我们每页显示3条</p>
<blockquote>
<p>总记录数 count 10</p>
<p>每页显示 pageSize 3</p>
<p>总页数 pageCount &#x3D; count%pageSize&#x3D;&#x3D;0? count&#x2F;pageSize + 1</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 查询第一页</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T limit <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">## 通用表达式</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span>tableName<span class="operator">&gt;</span> [<span class="keyword">where</span> ...] </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> limit (pageNum<span class="number">-1</span>)<span class="operator">*</span>pageSize,pageSize;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="数据表的关联关系"><a href="#数据表的关联关系" class="headerlink" title="数据表的关联关系"></a>数据表的关联关系</h2><hr>
<h3 id="关联关系介绍"><a href="#关联关系介绍" class="headerlink" title="关联关系介绍"></a>关联关系介绍</h3><hr>
<blockquote>
<p>MySQL是一个关系型数据库，不仅可以存储数据，还可以维护数据与数据之间的关系——通过在数据表中添加字段建立外键约束</p>
</blockquote>
<ul>
<li><p>数据与数据之间的关系</p>
<ul>
<li><p>一对一关联</p>
</li>
<li><p>一对多关联</p>
</li>
<li><p>多对一关联</p>
</li>
<li><p>多对多关联</p>
</li>
</ul>
</li>
</ul>
<h3 id="一对一关联"><a href="#一对一关联" class="headerlink" title="一对一关联"></a>一对一关联</h3><hr>
<blockquote>
<p>一个实体对应另一个实体</p>
</blockquote>
<ul>
<li><p>方案一 主键关联——两张数据表中主键相同的数据为相互对应的数据</p>
</li>
<li><p>方案二 唯一外键——在任意一张表中添加一个字段外键约束与另一张表主键关联，并且将外键添加唯一约束</p>
</li>
</ul>
<h3 id="一对多-与-多对一-关联"><a href="#一对多-与-多对一-关联" class="headerlink" title="一对多 与 多对一 关联"></a>一对多 与 多对一 关联</h3><hr>
<blockquote>
<p>一个实体对应多个实体</p>
</blockquote>
<ul>
<li>方案 在多的一段添加外键，与一的一端主键进行关联</li>
</ul>
<h3 id="多对多关联"><a href="#多对多关联" class="headerlink" title="多对多关联"></a>多对多关联</h3><hr>
<blockquote>
<p>多个实体对应其他多个实体</p>
</blockquote>
<ul>
<li>方案 额外创建一张关系表来维护多对多关联——在关系表中定义两个外键，分别与两个数据表的主键进行关联</li>
</ul>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><hr>
<blockquote>
<p>将一个列添加外键约束与另一张表的主键(唯一列)进行关联之后，这个外键约束的列添加的数据必须要在关联的主键字段中存在</p>
</blockquote>
<ul>
<li><p>案例：学生表 与 班级表 (在学生表中添加外键与班级表的主键进行关联)</p>
<blockquote>
<ol>
<li><p>先创建班级表</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line">  class_id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  class_name <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">  class_remark <span class="type">varchar</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建学生表(在学生表中添加外键与班级表中的主键进行关联)</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 方式一</span><br><span class="line">## 在创建表的时候，添加外键约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">  stu_num <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  stu_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  stu_gender <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  stu_age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  cid <span class="type">int</span>,</span><br><span class="line">  <span class="keyword">constraint</span> FK_STUDENTS_CLASSES <span class="keyword">foreign</span> key(cid) <span class="keyword">references</span> </span><br><span class="line">  classes(class_id) ## 添加外键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">## 方式二</span><br><span class="line">## 在创建表之后，为cid添加外键约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">  stu_num <span class="type">char</span>(<span class="number">8</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  stu_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  stu_gender <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  stu_age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  cid <span class="type">int</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> <span class="keyword">constraint</span> FK_STUDENTS_CLASSES </span><br><span class="line">  <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">foreign</span> key(cid) <span class="keyword">references</span> classes(class_id);</span><br><span class="line"></span><br><span class="line">#删除外键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">drop</span> <span class="keyword">foreign</span> key FK_STUDENTS_CLASSES;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>向班级表添加班级信息</p>
</li>
<li><p>向学生表中添加学生信息</p>
<blockquote>
<p>添加学生的时候，设置给cid外键列的值必须在其关联的主表classes的class_id列存在</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><hr>
<blockquote>
<p>当学生表中存在学生信息关联班级表的某条记录时，就不能对班级表的这条记录进行修改，删除。</p>
<p>如果一定要修改，需：</p>
<ol>
<li><p>将被引用的记录内外键cid设置为null</p>
</li>
<li><p>再修改原记录内的主键class_id</p>
</li>
<li><p>将cid中设置为null的记录重新修改关联为你所需要的新的class_id</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>我们可以使用级联操作来实现：</p>
<ol>
<li><p>在添加外键时，设置 <em>级联修改</em> 和 <em>级联删除</em> </p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 删除原有的外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">drop</span> <span class="keyword">foreign</span> key FK_STUDENTS_CLASSES;</span><br><span class="line"></span><br><span class="line">## 重新添加外键，并设置级联修改和级联删除</span><br><span class="line">## <span class="keyword">ON</span> <span class="keyword">UPDATE</span> 级联修改 <span class="keyword">ON</span> <span class="keyword">DELETE</span> 级联修改</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> <span class="keyword">constraint</span> FK_STUDENTS_CLASSES </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">foreign</span> key(cid) <span class="keyword">references</span> classes(class_id)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除class_id 的班级信息，学生表引用此班级信息的记录也会被同步删除</p>
</li>
</ol>
</blockquote>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><hr>
<blockquote>
<p>通过连接查询从多张数据表提取数据</p>
<p>再MySQL中可以使用join实现多表的联合查询——连接查询，join按照其功能不同分为三个操作：</p>
<ul>
<li><p>inner join 内连接</p>
</li>
<li><p>left join 左连接</p>
</li>
<li><p>right join 又连接</p>
</li>
</ul>
</blockquote>
<h3 id="内连接-INNER-JOIN"><a href="#内连接-INNER-JOIN" class="headerlink" title="内连接 INNER JOIN"></a>内连接 INNER JOIN</h3><hr>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">from</span> tableName1 <span class="keyword">inner</span> <span class="keyword">join</span> tableName2</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>笛卡尔积</p>
<blockquote>
<p>笛卡尔积(A集合&amp;B集合)：使用A中的每个记录一次关联B中每个记录，笛卡尔积&#x3D;A总数*B总数</p>
<p>如果直接执行，会获取两种数据表中的数据集合的笛卡尔积(一次使用tableName1 表中的每一条记录去匹配tableName2中的每一条数据)</p>
</blockquote>
</li>
<li><p>内连接条件</p>
<blockquote>
<p>两张表用inner join连接查询之后生成的笛卡尔积数据中很多都是无意义的，我们需要消除这个缺点</p>
</blockquote>
<ul>
<li><p>使用 <code>on</code> 设置两张表连接查询的匹配条件</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用where设置过滤条件：先生成笛卡尔积再从笛卡尔积中过滤数据(效率很低)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  students <span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">where</span> students.cid <span class="operator">=</span> classes.class_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用ON设置连接查询条件：先判断连接条件是否成立，如果成立两张表的数据进行</span></span><br><span class="line"><span class="comment">-- 组合生成一条结果记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> students.cid <span class="operator">=</span> classes.class_id;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>结果：只获取两种表中匹配条件成立的数据，任何一张表再另一张表如果没有找到对应匹配则不会出现在查询结果中</p>
</li>
</ul>
</li>
</ul>
<h3 id="左连接-LEFT-JOIN"><a href="#左连接-LEFT-JOIN" class="headerlink" title="左连接 LEFT JOIN"></a>左连接 LEFT JOIN</h3><hr>
<blockquote>
<p>显示左表中的所有数据，如果再右表中存在与左表记录满足匹配条件的数据，则进行匹配，如果左表不存在匹配数据，则显示为NULL</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> lefttable <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> righttable </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> 匹配条件 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="右连接-RIGHT-JOIN"><a href="#右连接-RIGHT-JOIN" class="headerlink" title="右连接 RIGHT JOIN"></a>右连接 RIGHT JOIN</h3><hr>
<blockquote>
<p>显示右表中的所有数据，如果再左表中存在与右表记录满足匹配条件的数据，则进行匹配，如果右表不存在匹配数据，则显示为NULL</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> lefttable <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> righttable </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> 匹配条件 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="数据表别名"><a href="#数据表别名" class="headerlink" title="数据表别名"></a>数据表别名</h3><hr>
<blockquote>
<p>如果在连接查询的多张表中存在相同名字的字段，我们可以使用<code>表名，字段名</code> 来进行区分，如果表名太长则不便于SQL语句的编写，我们可以使用数据表别名</p>
</blockquote>
<ul>
<li><p>示例</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.<span class="operator">*</span>,c.class_name</span><br><span class="line"><span class="keyword">from</span> students s</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> classes c ## 空格<span class="operator">+</span>别名</span><br><span class="line"><span class="keyword">ON</span> s.cid <span class="operator">=</span> c.class_id;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="子查询-x2F-嵌套查询"><a href="#子查询-x2F-嵌套查询" class="headerlink" title="子查询 &#x2F; 嵌套查询"></a>子查询 &#x2F; 嵌套查询</h3><hr>
<blockquote>
<p>先进行一次查询，第一次查询的结果作为第二次查询的源条件</p>
</blockquote>
<ul>
<li><p>示例一</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 先查询括号里面的</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  students <span class="keyword">where</span> cid <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">select</span> class_id <span class="keyword">from</span> classes <span class="keyword">where</span> class_name<span class="operator">=</span><span class="string">&#x27;Java2105&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>示例二</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果子查询返回的结果时多个值(单列多行)，条件使用IN</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  students <span class="keyword">where</span> cid </span><br><span class="line"><span class="keyword">IN</span> (<span class="keyword">select</span> class_id <span class="keyword">from</span> classes <span class="keyword">where</span> class_name <span class="keyword">LIKE</span> <span class="string">&#x27;Java%&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>示例三</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- (多行多列)先查询cid=1班级中的所有学生信息，将这些信息作为一个整体虚拟表</span></span><br><span class="line"><span class="comment">-- 在基于这个虚拟表查询性别为男的学生信息(&#x27;虚拟表&#x27;需要别名)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> cid<span class="operator">=</span><span class="number">1</span>) t </span><br><span class="line"><span class="keyword">where</span> t.stu_gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><hr>
<h3 id="存储过程介绍"><a href="#存储过程介绍" class="headerlink" title="存储过程介绍"></a>存储过程介绍</h3><hr>
<ul>
<li><p>SQL 指令执行过程</p>
<blockquote>
<ol>
<li><p>编写并允许SQL指令</p>
</li>
<li><p>通过数据库连接将SQL指令发送到数据库</p>
</li>
<li><p>数据库接收SQL指令至SQL引擎</p>
</li>
<li><p>SQL引擎编译并执行SQL指令</p>
</li>
<li><p>将执行SQL的结果通过数据库连接返回给用户端</p>
</li>
<li><p>用户端显示查询结果</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>存在的问题</p>
<blockquote>
<ol>
<li><p>如果我们需要重复多次执行相同的SQL，SQL执行都需要通过连接传递到MySQL，并且需要经过编译和执行的步骤</p>
</li>
<li><p>如果我们需要连续执行多个SQL指令，第二个SQL指令往往需要使用第一个SQL指令执行的结果作为参数</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>SQL指令执行过程存在问题解决方法——存储过程(按需配置)</p>
<blockquote>
<p>将能够完成特定功能的SQL指令进行封装(SQL指令集)，编译之后存储在数据库服务器上，并且为之去一个名字，客户端可以通过名字直接调用这个SQL指令集，获取执行结果</p>
</blockquote>
<ul>
<li><p>步骤</p>
<blockquote>
<ol>
<li><p>通过存储过程的名字进行调用</p>
</li>
<li><p>向数据库传输存储过程的名字</p>
</li>
<li><p>再数据库中通过存储过程的名字查询对应的指令集</p>
</li>
<li><p>执行指令集</p>
</li>
<li><p>返回执行结果</p>
</li>
<li><p>显示查询结果</p>
</li>
</ol>
</blockquote>
</li>
<li><p>优点</p>
<blockquote>
<ol>
<li><p>SQL指令无需客户端编写，通过网络传送，可以节省网络开销，同时避免SQL指令再网络传输过程中被恶意修改</p>
</li>
<li><p>存储过程经过编译创建并保存在数据库中的，执行过程无需重复的进行编译操作，对SQL指令的执行过程进行了性能提升</p>
</li>
<li><p>存储过程中多个SQL指令之间存在逻辑关系，支持流程控制语句(分支，循环)，可以实现更为复杂的业务</p>
</li>
</ol>
</blockquote>
</li>
<li><p>缺点</p>
<blockquote>
<ol>
<li><p>存储过程是根据不同的数据库进行编译，创建并存储在数据库中；当我们需要切换到其他的数据库产品时，需要重新编写针对于新数据库的存储过程</p>
</li>
<li><p>存储过程受限于数据库产品，如果需要高性能的优化会成为一个问题</p>
</li>
<li><p>在互联网的项目中，如果需要数据库的高(连接)并发访问，使用存储过程会增加数据库的连接执行时间(因为我们将复杂的业务交给了数据库进行处理)</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><hr>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 创建一个存储过程实现加法运算</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> <span class="operator">&lt;</span>procName<span class="operator">&gt;</span>(</span><br><span class="line">    [<span class="keyword">IN</span> param1 <span class="type">int</span>, <span class="keyword">IN</span> param2 <span class="type">int</span>,...,<span class="keyword">OUT</span> param3 <span class="type">int</span>]</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>案例</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## 创建一个存储过程实现加法运算</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test1(<span class="keyword">IN</span> a <span class="type">int</span>, <span class="keyword">IN</span> b <span class="type">int</span>, <span class="keyword">OUT</span> c <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">SET</span> c <span class="operator">=</span> a<span class="operator">+</span>b;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@m</span> <span class="operator">=</span> <span class="number">0</span>; ## 定义变量<span class="variable">@m</span></span><br><span class="line"><span class="keyword">call</span> test1(<span class="number">3</span>, <span class="number">4</span>, <span class="variable">@m</span>) ## 将<span class="variable">@m</span>传递给c</span><br><span class="line"><span class="comment">-- 显示变量值</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@m</span> <span class="keyword">from</span> DUAL;</span><br></pre></td></tr></table></figure></div>

<h3 id="存储过程中变量的使用"><a href="#存储过程中变量的使用" class="headerlink" title="存储过程中变量的使用"></a>存储过程中变量的使用</h3><hr>
<blockquote>
<p>局部变量 和 用户变量</p>
</blockquote>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><blockquote>
<p>定义在存储过程中的变量，只能在存储过程内部使用</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个存储过程，计算 输入参数的平方 与 输入参数/2 之和</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test2(<span class="keyword">IN</span> a <span class="type">int</span>, <span class="keyword">OUT</span> c <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> x <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>; ## 定义x <span class="type">int</span>类型 默认值为<span class="number">0</span></span><br><span class="line">    <span class="keyword">declare</span> y <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">set</span> x <span class="operator">=</span> a<span class="operator">*</span>a; ## 设置x的值</span><br><span class="line">    <span class="keyword">set</span> y <span class="operator">=</span> a<span class="operator">/</span><span class="number">2</span>;</span><br><span class="line">    <span class="keyword">set</span> r <span class="operator">=</span> x<span class="operator">+</span>y;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> x <span class="keyword">from</span> DUAL; ## 无结果，局部变量不会出现在DUAL内</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>局部变量要定义在存储过程中，而且必须定义在存储过程开始</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="operator">&lt;</span>变量名<span class="operator">&gt;</span> <span class="operator">&lt;</span>变量类型<span class="operator">&gt;</span> [<span class="keyword">default</span> 默认值];</span><br></pre></td></tr></table></figure></div>

<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><blockquote>
<p>相当于全局变量，定义的用户变量可以通过<code>select @attrName from DUAL</code>查询到</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用户变量直接使用set设置</span></span><br><span class="line"><span class="comment">-- 用户变量需要舒勇@来修饰</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@n</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">call</span> test2(<span class="number">6</span>,<span class="variable">@n</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@n</span> <span class="keyword">from</span> DUAL;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>注意</p>
<blockquote>
<p>因为用户变量相当于全局变量，可以在SQL指令以及多个存储过程中共享，用户变量过多会导致程序不易理解，在开发中少使用</p>
</blockquote>
</li>
</ul>
<h5 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h5><blockquote>
<p>无论时局部变量还是用户变量，都是使用<code>set</code> 关键字修改值</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@n</span><span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">set</span> y <span class="operator">=</span> a<span class="operator">+</span>b;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>在SQL语句中赋值给变量</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test3(<span class="keyword">OUT</span> c <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(stu_num) <span class="keyword">INTO</span> c <span class="keyword">from</span> students;</span><br><span class="line">    ## 使用select...INTO关键字段，赋值给c</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="存储过程的参数"><a href="#存储过程的参数" class="headerlink" title="存储过程的参数"></a>存储过程的参数</h3><hr>
<blockquote>
<p>MySQL存储过程的参数：IN &#x2F; OUT &#x2F; INOUT</p>
</blockquote>
<h4 id="IN-输入参数"><a href="#IN-输入参数" class="headerlink" title="IN 输入参数"></a>IN 输入参数</h4><blockquote>
<p>在调用存储过程中传递数据给存储过程的参数(在调用的过程中必须为具有实际值的变量 或者 字面值)</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test4(</span><br><span class="line">    <span class="keyword">IN</span> snum <span class="type">char</span>(<span class="number">8</span>), <span class="keyword">IN</span> sname <span class="type">varchar</span>(<span class="number">20</span>), <span class="keyword">IN</span> gender <span class="type">char</span>(<span class="number">2</span>), <span class="keyword">IN</span> age <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">IN</span> cid <span class="type">int</span>, <span class="keyword">IN</span> remark <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> students(stu_num,stu_name,stu_gender,stu_age,cid,remark)</span><br><span class="line">    <span class="keyword">values</span>(snum,sname,gender,age,cid,remark);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="OUT-输出参数"><a href="#OUT-输出参数" class="headerlink" title="OUT 输出参数"></a>OUT 输出参数</h4><blockquote>
<p>将存储过程中产生的数据返回给过程调用者</p>
</blockquote>
<h4 id="INOUT-输入输出参数"><a href="#INOUT-输入输出参数" class="headerlink" title="INOUT 输入输出参数"></a>INOUT 输入输出参数</h4><blockquote>
<p>输入与输出都在同一个参数上传递</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> test6(<span class="keyword">INOUT</span> str <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> stu_name <span class="keyword">INTO</span> str <span class="keyword">from</span> students <span class="keyword">where</span> stu_num<span class="operator">=</span>str;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@name</span><span class="operator">=</span><span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line"><span class="keyword">call</span> test6(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@name</span> <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure></div>

<h3 id="存储过程中的流程控制"><a href="#存储过程中的流程控制" class="headerlink" title="存储过程中的流程控制"></a>存储过程中的流程控制</h3><hr>
<blockquote>
<p>在存储过程中支持流程控制语句用于实现逻辑的控制</p>
</blockquote>
<h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><ul>
<li><p><code>if-then-else</code></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单分支</span></span><br><span class="line">if conditions <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- SQL</span></span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 双分支</span></span><br><span class="line">if confitions <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- SQL1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- SQL2</span></span><br><span class="line"><span class="keyword">end</span> if;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>case</code></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> 变量名</span><br><span class="line"><span class="keyword">when</span> value1 <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- SQL1</span></span><br><span class="line"><span class="keyword">when</span> value2 <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- SQL2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- SQL3</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul>
<li><p><code>while</code></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">while i <span class="operator">&lt;</span> num do</span><br><span class="line">    <span class="comment">--SQL</span></span><br><span class="line">    <span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>repeat</code></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">repeat</span><br><span class="line">    <span class="comment">--SQL</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> classes(class_name,remark) </span><br><span class="line">    <span class="keyword">values</span>(CONCAT(<span class="string">&#x27;Python&#x27;</span>,i),<span class="string">&#x27;....&#x27;</span>);</span><br><span class="line">    <span class="keyword">set</span> i <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span></span><br><span class="line">until i <span class="operator">&gt;</span> num <span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>loop</code></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line"><span class="keyword">set</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">myloop:loop</span><br><span class="line">    <span class="comment">--SQL</span></span><br><span class="line">    if i <span class="operator">=</span> num <span class="keyword">then</span></span><br><span class="line">        leave myloop;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> loop;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="存储过程管理"><a href="#存储过程管理" class="headerlink" title="存储过程管理"></a>存储过程管理</h3><hr>
<h4 id="查询存储过程"><a href="#查询存储过程" class="headerlink" title="查询存储过程"></a>查询存储过程</h4><blockquote>
<p>存储过程是属于某个数据库的，也就是说当我们将存储过程创建在某个数据库之后，只能在当前数据库调用此存储过程</p>
<p>查询：查询某个数据库中有哪些存储过程</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据数据库名查询数据库内存储过程</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> status [<span class="keyword">where</span> db<span class="operator">=</span>数据库名];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询某数据库中特定存储过程的实现细节</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 数据库名.存储过程;</span><br></pre></td></tr></table></figure></div>

<h4 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h4><blockquote>
<p>修改存储过程的特征 &#x2F; 特性</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">procedure</span> <span class="operator">&lt;</span>proc_name<span class="operator">&gt;</span> 特征<span class="number">1</span> [特征<span class="number">2</span> 特征<span class="number">3</span> ...];</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>存储过程的特征参数</p>
<ul>
<li><p><code>CONTAINS SQL</code> 表示子程序包含 SQL 语句，但不包含读或写数据的语句</p>
</li>
<li><p><code>NO SQL</code> 表示子程序中不包含 SQL 语句</p>
</li>
<li><p><code>READS SQL DATA</code> 表示子程序中不包含 SQL 语句</p>
</li>
<li><p><code>MODIFIES SQL DATA</code> 表示子程序中包含写数据的语句</p>
</li>
<li><p><code>SQL SECURITY</code> {DEFINER | INVOKER} 指明谁有权限来执行</p>
<ul>
<li><p>DEFINER 表示只有定义者自己才能够执行</p>
</li>
<li><p>INVOKER 表示调用者可以执行</p>
</li>
</ul>
</li>
<li><p><code>COMMENT &#39;string&#39;</code> 表示注释信息</p>
</li>
</ul>
</li>
</ul>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- drop 删除数据库中的对象</span></span><br><span class="line"><span class="comment">-- delete 删除数据表中的数据</span></span><br><span class="line">dro <span class="keyword">procedure</span> proc_test1</span><br></pre></td></tr></table></figure></div>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><hr>
<blockquote>
<p>创建一个存储过程，需要返回查询语句查询到的多条数据</p>
</blockquote>
<p><code>concat_ws(&#39;~&#39;, x, xx, aa) = x~xx~aa</code> 拼接 </p>
<h4 id="游标的概念"><a href="#游标的概念" class="headerlink" title="游标的概念"></a>游标的概念</h4><blockquote>
<p>游标可以用来一次取出查询结果中的每一条数据，逐个读取</p>
</blockquote>
<h4 id="游标的使用步骤"><a href="#游标的使用步骤" class="headerlink" title="游标的使用步骤"></a>游标的使用步骤</h4><ol>
<li><p>声明游标</p>
<ul>
<li><p>声明游标语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="operator">&lt;</span>查询语句<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>打开游标</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> cursor_name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>使用游标</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> i<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">while i<span class="operator">&lt;</span>num do</span><br><span class="line">    <span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> bname,bauthor,bprice; ## 循环取出</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>关闭游标</p>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">close</span> cursor_name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><hr>
<h3 id="触发器介绍"><a href="#触发器介绍" class="headerlink" title="触发器介绍"></a>触发器介绍</h3><hr>
<blockquote>
<p>触发器是一种特殊的存储过程，能够完成特定功能，存储在数据库服务器上的SQL片段，但是触发器无需调用，当对数据表中的数据执行DML操作时自动触发这个SQL片段的执行，无需手动调用</p>
<p>在MySQL中只有执行insert\delete\update操作才能触发触发器的执行</p>
</blockquote>
<h3 id="触发器的使用"><a href="#触发器的使用" class="headerlink" title="触发器的使用"></a>触发器的使用</h3><hr>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_name</span><br><span class="line"><span class="operator">&lt;</span>before<span class="operator">|</span>after<span class="operator">&gt;</span>   <span class="comment">--定义触发时机</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span><span class="operator">|</span><span class="keyword">delete</span><span class="operator">|</span><span class="keyword">update</span><span class="operator">&gt;</span>  <span class="comment">--定义DML类型</span></span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  <span class="comment">--声明为行级触发器(只要操作一条记录就触发触发器一次)</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test1</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> students</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h4><ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> tri_name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="NEW-与-OLD"><a href="#NEW-与-OLD" class="headerlink" title="NEW 与 OLD"></a>NEW 与 OLD</h3><hr>
<blockquote>
<p>我们可以通过<code>NEW</code> 和 <code>OLD</code> 关键字在触发器中货期触发器的MDML操作的数据</p>
<ul>
<li><p><code>NEW</code>：在触发器中用于获取insert操作添加的数据，update操作修改后的记录</p>
</li>
<li><p><code>OLD</code>：在触发器中用于获取delete操作删除前的数据，update操作修改前的数据</p>
</li>
</ul>
</blockquote>
<h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><ul>
<li><p>insert操作</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test1</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> students</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(<span class="type">time</span>, log_text) </span><br><span class="line"><span class="keyword">values</span>(now(), concat(<span class="string">&#x27;添加&#x27;</span>, NEW.stu_name, <span class="string">&#x27;学生信息&#x27;</span>));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>update操作</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test2</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> students <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(<span class="type">time</span>, log_text) </span><br><span class="line"><span class="keyword">values</span>(now(), concat(<span class="string">&#x27;修改&#x27;</span>, NEW.stu_num, NEW.stu_name));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="OLD"><a href="#OLD" class="headerlink" title="OLD"></a>OLD</h4><ul>
<li><p>delete操作</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test2</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> students <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(<span class="type">time</span>, log_text) </span><br><span class="line"><span class="keyword">values</span>(now(), concat(<span class="string">&#x27;删除&#x27;</span>, OLD.stu_num, <span class="string">&#x27;学生信息&#x27;</span>));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>update操作</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tri_test2</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> students <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stulogs(<span class="type">time</span>, log_text) </span><br><span class="line"><span class="keyword">values</span>(now(), concat(<span class="string">&#x27;修改&#x27;</span>, OLD.stu_name, NEW.stu_name));</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>触发器时自动执行的，当对触发器相应的表执行响应的DML操作时立即执行</p>
</li>
<li><p>触发器可以实现表中的数据的级联操作(关联操作)，有利于保证数据库的完整性</p>
</li>
<li><p>触发器可以对DML操作的数据进行更为复杂的合法性校验</p>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>使用触发器实现的业务逻辑如果出现问题，将难以定位，后期维护难</p>
</li>
<li><p>如果大量使用，容易导致代码结构杂乱，增加了程序的复杂性</p>
</li>
<li><p>当触发器操作的数据量比较大时，执行效率会大大降低</p>
</li>
</ul>
<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ul>
<li><p>在互联网项目中，应避免使用触发器</p>
</li>
<li><p>对于并发量不大的项目可以选择使用存储过程，但是在互联网引用中不提倡使用存储过程(原因：存储过程将实现业务逻辑交给数据库处理，一则增加了数据库的负载，二则不利于数据库的迁移)</p>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><hr>
<h3 id="视图的概念"><a href="#视图的概念" class="headerlink" title="视图的概念"></a>视图的概念</h3><hr>
<blockquote>
<p>视图就是由数据库中一张表或者多张表根据特定的条件查询出的数据构造成的虚拟表</p>
</blockquote>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><hr>
<ul>
<li><p>安全性</p>
<blockquote>
<p>如果我们直接将数据表授权给用户操作，那么用户可以操作数据表中的所有数据，假如我们想要对数据表中的部分数据进行保护，可以将公开的数据生成视图，授权用户访问视图；用户通过查询视图可以获取数据表中公开的数据，从而达到将数据表中的部分数据对用户隐藏</p>
</blockquote>
</li>
<li><p>简单性</p>
<blockquote>
<p>如果我们需要查询的数据来源于多张数据表，可以使用多表连接查询来实现；我们通过视图将这些连表查询的结果对用户开放，用户则可以直接通过查询视图获取多表数据，操作更便捷</p>
</blockquote>
</li>
</ul>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><hr>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_test1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> stu_genter<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>; ## 单表</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_test2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> s.stu_name,b.book_name,borrow_num</span><br><span class="line"><span class="keyword">from</span> books b <span class="keyword">inner</span> <span class="keyword">join</span> records r <span class="keyword">inner</span> <span class="keyword">join</span> student s</span><br><span class="line"><span class="keyword">on</span> b.book_id<span class="operator">=</span>r.bid <span class="keyword">and</span> r.snum<span class="operator">=</span>s.stu_num;  ## 多表</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询视图</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_test2;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="视图数据的特性"><a href="#视图数据的特性" class="headerlink" title="视图数据的特性"></a>视图数据的特性</h3><hr>
<ul>
<li><p>查询操作</p>
<blockquote>
<p>如果在数据表中添加了新的数据，而且这个数据满足创建视图时的查询语句条件，通过查询视图也可以查询出新增的数据；当删除原表中男足查询条件的数据时，也会从视图中消失</p>
</blockquote>
</li>
<li><p>新增数据</p>
<blockquote>
<p>如果在视图中添加数据，数据会被添加到原数据表</p>
</blockquote>
</li>
<li><p>删除数据</p>
<blockquote>
<p>如果在视图中删除数据，数据也将在原表中被删除</p>
</blockquote>
</li>
<li><p>修改数据</p>
<blockquote>
<p>如果在视图中修改数据，数据也将在原表中被修改</p>
</blockquote>
</li>
</ul>
<h4 id="使用建议-1"><a href="#使用建议-1" class="headerlink" title="使用建议"></a>使用建议</h4><blockquote>
<p>对复杂查询简化操作，并且不会对数据进行修改的情况下可以使用视图</p>
</blockquote>
<h3 id="查询视图结构"><a href="#查询视图结构" class="headerlink" title="查询视图结构"></a>查询视图结构</h3><hr>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">desc</span> view_test2;</span><br></pre></td></tr></table></figure></div>

<h3 id="修改视图结构"><a href="#修改视图结构" class="headerlink" title="修改视图结构"></a>修改视图结构</h3><div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--方式1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">OR</span> REPLACE <span class="keyword">view</span> view_test1 # 关键段 <span class="keyword">OR</span> REPLACE 若存在则覆盖</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--方式2</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> view_test1</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br></pre></td></tr></table></figure></div>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><hr>
<blockquote>
<p>删除数据表时会同时删除数据表中的数据，但是删除视图时不会影响原表中的数据</p>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_test1</span><br></pre></td></tr></table></figure></div>



<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><hr>
<blockquote>
<p>数据库是用来存储数据的，在互联网应用中数据库中存储的数据可能会很多(大数据)，数据表中数据的查询速率会随着数据量的增长逐渐变慢，从而导致响应用户请求的速度变慢——用户体验差</p>
</blockquote>
<h3 id="索引的介绍"><a href="#索引的介绍" class="headerlink" title="索引的介绍"></a>索引的介绍</h3><hr>
<blockquote>
<p>索引就是用来提高数据表中数据的查询效率的</p>
<p>将数据表中某一列&#x2F;某几列的值取出来构造成便于查找的结构进行存储，生成数据表的目录，当我们进行数据查询时，则现在目录中进行查找得到对应数据的地址，然后再到数据表中根据地址快速获取数据记录，避免全表扫描</p>
</blockquote>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><hr>
<blockquote>
<p>MySQL中的索引根据创建索引的列的不同分为：</p>
<ul>
<li><p>主键索引：在主键字段创建的索引</p>
</li>
<li><p>唯一索引：在唯一约束字段创建的索引，可以为NULL</p>
</li>
<li><p>普通索引：没有限制，在普通字段创建的索引</p>
</li>
<li><p>组合索引：两个及以上的字段创建的索引</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>说明</p>
<blockquote>
<ol>
<li><p>在创建数据表时，将字段声明为主键时，会自动在主键字段创建主键索引</p>
</li>
<li><p>在创建数据表时，将字段声明为唯一键，会自动在唯一字段创建唯一索引</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><hr>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">## <span class="keyword">unique</span> 唯一索引，无 普通索引</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_索引名 <span class="keyword">on</span> 表名(字段名);</span><br><span class="line"></span><br><span class="line">## 组合索引，需要多个字段值</span><br><span class="line"><span class="keyword">create</span> index index_索引名 <span class="keyword">on</span> 表名(字段名<span class="number">1</span>，<span class="number">2</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><blockquote>
<p>通过此索引进行全文检索操作</p>
</blockquote>
<ul>
<li><p>语法</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> fulltext index index_索引名 <span class="keyword">on</span> 表名(字段名);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><hr>
<blockquote>
<p>索引创建完成之后无需调用，当根据创建索引的列进行数据查询的时候，会自动使用索引</p>
<p>组合索引需要根据创建索引的所有字段进行查询时触发</p>
</blockquote>
<ul>
<li><p>在命令行中查看查询语句的查询规划</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="operator">&lt;</span><span class="keyword">SQL</span>语句<span class="operator">&gt;</span>\G;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><hr>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--方案1 ，</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tb_testindex\G;</span><br><span class="line"><span class="comment">--方案2 查询数据表的索引</span></span><br><span class="line"><span class="keyword">show</span> indexes <span class="keyword">from</span> tb_testindex;</span><br><span class="line"><span class="comment">--方案3 查询索引</span></span><br><span class="line"><span class="keyword">show</span> keys <span class="keyword">from</span> tb_testindex;</span><br></pre></td></tr></table></figure></div>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><hr>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--索引是建立在表的字段上的，不同的表可能会出现相同名称的索引，</span></span><br><span class="line"><span class="comment">--因此删除索引时需要指定表名</span></span><br><span class="line"><span class="keyword">drop</span> index index_test3 <span class="keyword">on</span> tb_testindex;</span><br></pre></td></tr></table></figure></div>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><hr>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><blockquote>
<ol>
<li><p>索引大大降低了数据库服务器在执行查询操作时扫描的数据</p>
</li>
<li><p>索引可以避免服务器排序，将随机IO变成顺序IO</p>
</li>
</ol>
</blockquote>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<ol>
<li><p>索引是根据数据表列创建的，当数据表中数据发生DML操作时，索引页也需要更新</p>
</li>
<li><p>索引文件也会占用磁盘空间</p>
</li>
</ol>
</blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote>
<ol>
<li><p>数据表中数据不多时，全表扫描可能更快，不要使用索引</p>
</li>
<li><p>数据量大但是DML操作很频繁，不建议使用</p>
</li>
<li><p>不要在数据重复高度高的列上创建索引</p>
</li>
<li><p>创建索引之后，要注意查询SQL语句的编写，避免索引失效</p>
</li>
</ol>
</blockquote>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><hr>
<h3 id="数据库事务介绍"><a href="#数据库事务介绍" class="headerlink" title="数据库事务介绍"></a>数据库事务介绍</h3><hr>
<blockquote>
<p>我们把完成特定的业务的多个数据库DML操作步骤称为一个数据库事务</p>
</blockquote>
<h3 id="数据库事务的特性"><a href="#数据库事务的特性" class="headerlink" title="数据库事务的特性"></a>数据库事务的特性</h3><hr>
<blockquote>
<p>ACID特性</p>
</blockquote>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote>
<p>Atomicity ：一个事务中的多个DML操作，要么同时执行成功，要么同时失败</p>
</blockquote>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><blockquote>
<p>Consistency：事务执行之前和事务执行之后，数据库中的数据是一致的，完整性和一致性不能破坏</p>
</blockquote>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><blockquote>
<p>Isolation：数据库允许多个事务同时进行(张三借Java书同时允许李四借)，多个并行的事务之间不能相互影响</p>
</blockquote>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><blockquote>
<p>Durability：事务完成之后，对数据得到操作是永久的</p>
</blockquote>
<h3 id="MySQL事务管理"><a href="#MySQL事务管理" class="headerlink" title="MySQL事务管理"></a>MySQL事务管理</h3><hr>
<h4 id="自动提交与手动提交"><a href="#自动提交与手动提交" class="headerlink" title="自动提交与手动提交"></a>自动提交与手动提交</h4><blockquote>
<p>在MySQL中，默认DML指令的执行是自动提交的，当我们执行一个DML指令之后，自动同步到数据库</p>
</blockquote>
<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><blockquote>
<p>开启事务，关闭自动提交</p>
<ul>
<li><p>当开始事务第一个操作之前执行<code>start transaction</code> 开启事务</p>
</li>
<li><p>依次执行事务中的每个DML操作</p>
</li>
<li><p>如果在执行的过程中的任何位置出现异常，则执行<code>rollback</code> 回滚事务</p>
</li>
<li><p>如果所有操作都执行成功，则在最后执行<code>commit</code> 提交</p>
</li>
</ul>
</blockquote>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction; ## 开始事务</span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">rollback</span>; ## 错误则回滚</span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">commit</span>; ## 全部正确则提交</span><br></pre></td></tr></table></figure></div>

<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><h5 id="MySQL数据库事务隔离级别"><a href="#MySQL数据库事务隔离级别" class="headerlink" title="MySQL数据库事务隔离级别"></a>MySQL数据库事务隔离级别</h5><ul>
<li><p>读未提交</p>
<blockquote>
<p>T2可以读取T1执行但未提交的数据，可能会导致出现脏读</p>
<p>脏读：一个事务读取到了另一个事务中未提交的数据</p>
</blockquote>
</li>
<li><p>读已提交</p>
<blockquote>
<p>T2只能读取T1已经提交的数据，可以避免脏读，但可能会导致不可重复读(虚读)</p>
<p>虚读：在同一个事务中，两次查询操作读取到数据不一致</p>
</blockquote>
</li>
<li><p>可重复读</p>
<blockquote>
<p>T2执行第一次查询后，在事务结束之前其他事务不能修改对应数据，避免了不可重复读(虚读)，但可能导致幻读</p>
<p>幻读：T2对数据表中的数据进行修改然后查询，在查询之前T1像数据表中新增了一条数据，就导致T2以为修改了所有数据，但却查询除了与修改不一致的数据(T1事务新增的数据)</p>
</blockquote>
</li>
<li><p>串行化</p>
<blockquote>
<p>同时只允许一个事务对数据表进行操作，避免了脏读，虚读，幻读问题</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读(虚读)</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read uncommitted</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">read committed</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">repeatable read</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">serializable</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h5 id="设置数据库事务隔离级别"><a href="#设置数据库事务隔离级别" class="headerlink" title="设置数据库事务隔离级别"></a>设置数据库事务隔离级别</h5><blockquote>
<p>通过设置数据库默认的事务隔离级别来控制事务之间的隔离性，也可以通过客户端与数据库连接设置来设置事务间的隔离性(在应用程序中设置)</p>
<p>MySQL数据库默认的隔离级别为<code>可重复读</code></p>
</blockquote>
<ul>
<li><p>查看MySQL数据库默认的隔离级别</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置MySQL默认隔离级别</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> session transaction isolation level <span class="operator">&lt;</span>read committed<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><hr>
<h3 id="数据库设计流程"><a href="#数据库设计流程" class="headerlink" title="数据库设计流程"></a>数据库设计流程</h3><hr>
<ol>
<li><p><strong>根据应用系统功能，分析数据实体</strong>(实体，就是要存储的数据对象)</p>
<ul>
<li>电商系统：商品，用户，订单</li>
</ul>
</li>
<li><p><strong>提取实体的数据项</strong>(数据项，就是实体的属性)</p>
<ul>
<li>商品(商品名称，商品图片)</li>
</ul>
</li>
<li><p><strong>根据数据库设计三范式规范视图的数据项</strong></p>
<blockquote>
<p>检查实体的数据是否满足数据库设计三范式，如果实体的数据项不满足三范式，可能会导致数据的冗余，从而引起数据维护困难，破环数据一致性等问题</p>
</blockquote>
</li>
<li><p><strong>绘制E-R图</strong>(实体关系图，直观的展示实体与实体之间的关系)</p>
</li>
<li><p><strong>数据库建模</strong></p>
<ul>
<li><p>三线图进行数据表设计</p>
</li>
<li><p>PowerDesigner</p>
</li>
<li><p>PDMan</p>
</li>
</ul>
</li>
<li><p><strong>建库建表</strong>(编写SQL指令创建数据库，数据表)</p>
</li>
<li><p><strong>添加测试数据，SQL测试</strong></p>
</li>
</ol>
<h4 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h4><ul>
<li><p>第一范式(1NF)：要求数据表中的字段(列)不可再分</p>
</li>
<li><p>第二范式(2NF)：不存在非关键字段对关键字段的部分依赖</p>
</li>
<li><p>第三范式(3NF)：不存在非关键字段不存在传递依赖</p>
</li>
</ul>
<h4 id="绘制E-R图"><a href="#绘制E-R图" class="headerlink" title="绘制E-R图"></a>绘制E-R图</h4><blockquote>
<p>E-R实体关系图，用于直观的体现实体与实体之间的关联关系(一对一，一对多，多对一，多对多)</p>
</blockquote>
<h5 id="E-R图基本图例"><a href="#E-R图基本图例" class="headerlink" title="E-R图基本图例"></a>E-R图基本图例</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-15-17-26-47-image.png"
                     
                ></p>
<ul>
<li><p>示例</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-15-17-27-15-image.png"
                     
                ></p>
</li>
</ul>
<h5 id="三线图"><a href="#三线图" class="headerlink" title="三线图"></a>三线图</h5><blockquote>
<p>统一数据实体的表结构</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-15-17-40-28-image.png"
                     
                ></p>
<h4 id="数据库建模"><a href="#数据库建模" class="headerlink" title="数据库建模"></a>数据库建模</h4><blockquote>
<ul>
<li><p>E-R 图 数据表设计 建库建表</p>
</li>
<li><p>PowerDesigner建模工具 导出数据表</p>
</li>
<li><p>PDMan建模工具</p>
</li>
</ul>
</blockquote>
<h5 id="PowerDesigner使用"><a href="#PowerDesigner使用" class="headerlink" title="PowerDesigner使用"></a>PowerDesigner使用</h5><ul>
<li><p>概念数据模型 - E-R 图</p>
</li>
<li><p>逻辑数据模型 - 体现实体主外键关联</p>
</li>
<li><p>物理数据模型</p>
<ul>
<li><p>可以对物理模型进行微调</p>
</li>
<li><p>可以通过物理数据模型生成建库建表的SQL语句</p>
</li>
</ul>
</li>
<li><p>面向对象模型</p>
<ul>
<li>可以根据语言设置，生成实体类</li>
</ul>
</li>
</ul>
<blockquote>
<p>在企业项目开发，通常是不会使用建模工具来生成数据表，实体类的，因为生成的代码规范不合乎代码需求</p>
</blockquote>
]]></content>
      <tags>
        <tag>MySQL Study</tag>
      </tags>
  </entry>
  <entry>
    <title>poetry使用</title>
    <url>/2023/03/09/poetry%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Poetry"><a href="#Poetry" class="headerlink" title="Poetry"></a>Poetry</h3><hr>
<p>使用pyproject.toml管理整个项目的依赖</p>
<h4 id="安装poetry"><a href="#安装poetry" class="headerlink" title="安装poetry"></a>安装poetry</h4><ol>
<li><p>安装pipx为每个包自动创建隔离环境，方便管理</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pipx</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>安装poetry</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pipx install poetry</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="项目中使用portry"><a href="#项目中使用portry" class="headerlink" title="项目中使用portry"></a>项目中使用portry</h4><ol>
<li><p>初始化pyproject.toml</p>
<p>在项目路径中使用:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">poetry init</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建项目虚拟环境</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use python</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进入虚拟环境</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加新依赖</p>
<p>在pyproject.toml文件中添加如下内容:</p>
<div class="highlight-container" data-rel="Toml"><figure class="iseeu highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[tool.poetry.source]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;aliyun&quot;</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://mirrors.aliyun.com/pypi/simple&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>添加普通依赖:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">poetry add &lt;pakge_name&gt;</span><br></pre></td></tr></table></figure></div>

<p>添加开发依赖:</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">poetry add &lt;pakge_name&gt; -D</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>测试</p>
<p>使用pytest</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">poetry run pytest</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <tags>
        <tag>poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2023/04/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ol>
<li><p>进程和线程之间有什么区别？</p>
<blockquote>
<p>进程是运行中的程序，线程是进程的内部的一个执行序列<br>进程是资源分配单元，线程是执行单元<br>进程间切换代价大，线程间切换代价小<br>进程拥有资源多，线程拥有资源少<br>多个线程共享进程资源</p>
<p>进程为啥切换代价比线程要大？</p>
<blockquote>
<p>物理地址就是真实的地址，这种寻址方式很容易破坏操作系统，而且使得操作系统中同时运行两个或以上的程序几乎是不可能的（第一个程序给物理内存地址赋值 10，第二个程序也同样给这个地址赋值为 100，那么第二个程序的赋值会覆盖掉第一个程序所赋的值，这会造成两个程序同时崩溃）。</p>
<p>当然，也不是完全不可能，有一种方式可以实现比较粗糙的并发。就是说，我们将空闲的进程存储在磁盘上，这样当它们不运行时就不会占用内存，当进程需要运行的时候再从磁盘上转到内存上来，不过很显然这种方式比较浪费时间。</p>
<p>于是，我们考虑，把所有进程对应的内存一直留在物理内存中，给每个进程分别划分各自的区域，这样，发生上下文切换的时候就切换到特定的区域<br>那问题还是很明显的，就是仍然没法避免破坏操作系统，因为各个进程之间可以随意读取、写入内容。</p>
<p>所以，我们需要一种机制对每个进程使用的地址进行保护，因此操作系统创造了一个新的内存模型，那就是虚拟地址空间, 就是说，每个进程都拥有一个自己的虚拟地址空间，并且独立于其他进程的地址空间，然后每个进程包含的栈、堆、代码段这些都会从这个地址空间中被分配一个地址，这个地址就被称为虚拟地址。底层指令写入的地址也是虚拟地址。</p>
<p>有了虚拟地址空间后，CPU 就可以通过虚拟地址转换成物理地址这样一个过程，来间接访问物理内存了。</p>
<p>地址转换需要两个东西，一个是 CPU 上的内存管理单元 MMU，另一个是内存中的页表，页表中存的虚拟地址到物理地址的映射。</p>
<p>但是呢，每次访问内存，都需要进行虚拟地址到物理地址的转换，对吧，这样的话，页表就会被频繁地访问，而页表又是存在于内存中的。所以说，访问页表（内存）次数太多导致其成为了操作系统地一个性能瓶颈。</p>
<p>于是，引入了转换检测缓冲区 TLB，也就是快表，其实就是一个缓存，把经常访问到的内存地址映射存在 TLB 中，因为 TLB 是在 CPU 的 MMU 中的嘛，所以访问起来非常快。</p>
<p>然后，正是因为 TLB 这个东西，导致了进程切换比线程切换慢。</p>
<p>由于进程切换会涉及到虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢。</p>
<p>而线程切换呢，由于不涉及虚拟地址空间的切换，所以也就不存在这个问题了。</p>
</blockquote>
</blockquote>
</li>
<li><p>进程间有哪些通信方式？</p>
<ol>
<li><p>管道:</p>
<blockquote>
<p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有关联的进程间使用，进程的关系通常是指父子进程关系。</p>
</blockquote>
</li>
<li><p>消息队列通信:</p>
<blockquote>
<p>消息队列是由消息的链表存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</blockquote>
</li>
<li><p>信号量:</p>
<blockquote>
<p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</blockquote>
</li>
<li><p>信号:</p>
<blockquote>
<p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件以及发生。</p>
</blockquote>
</li>
<li><p>共享内存通信:</p>
<blockquote>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个远程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间简单通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
</blockquote>
</li>
<li><p>socket:</p>
<blockquote>
<p>套接字机制与其他机制不同的是，它可用于不同机器间的进程通信。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>简述 socket 中 select 与 epoll 的使用场景以及区别?</p>
<blockquote>
<p>两个网络模型本质上都是IO多路复用的</p>
<p>select 需要不断的去轮询数据，时间复杂度为O(n)，性能比较低，并且它的文件描述符也是有限制的。像常见的服务器软件 apache 用的就是这种网络类型。</p>
<p>而 epoll 则不一样，他不会去轮询，而是会注册一个监听事件，每当数据有变化的时候，就会通知，像 nginx 底层的网络模型就是用的 epoll ，这个也是为啥nginx 能处理高并发的主要原因。</p>
<p>表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。</p>
<p>select 低效是因为每次它都需要轮询，但低效也是相对的，是情况而定，也可以通过良好的设计改善。</p>
</blockquote>
</li>
<li><p>epoll 中水平触发以及边缘触发有什么不同?</p>
<ul>
<li><p>Level_triggered(水平触发):</p>
<blockquote>
<p>当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知处理程序去读写，如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait() 时，它还会通知你在没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量的你不需要读写的就绪文件描述符，而他们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！</p>
</blockquote>
</li>
<li><p>Edge_triggered(边缘触发):</p>
<blockquote>
<p>当被监控的文件描述符上有可读写事件发生时，epoll_wait() 会通知程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait() 时，它不会通知你，也就是它只会通知一次，知道该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Linux 进程调度中有哪些常见算法以及策略?</p>
<blockquote>
<ol>
<li><p>先来先服务和短作业(进程)优先调度算法</p>
</li>
<li><p>高优先权优先调度算法</p>
<ul>
<li><p>非抢占式优先权算法</p>
</li>
<li><p>抢占式优先权调度算法</p>
</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ol>
<blockquote>
<p>进程的状态有哪几种?</p>
<ol>
<li><p>运行态:</p>
<blockquote>
<p>该状态表明进程在实际占用CPU。</p>
</blockquote>
</li>
<li><p>就绪态:</p>
<blockquote>
<p>该状态下进程可以运行，但因为其他进程正在运行而暂时停止。</p>
</blockquote>
</li>
<li><p>阻塞态:</p>
<blockquote>
<p>该状态下进程不能运行，除非某种外部事件的发送。</p>
</blockquote>
</li>
</ol>
<p>运行态 –&gt; 等待态</p>
<blockquote>
<p>往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的</p>
</blockquote>
<p>等待态 –&gt; 就绪态</p>
<blockquote>
<p>则是等待的条件已满足，只需分配到处理器后就能运行</p>
</blockquote>
<p>运行态 –&gt; 就绪态</p>
<blockquote>
<p>不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等</p>
</blockquote>
<p>就绪态 –&gt; 运行态</p>
<blockquote>
<p>系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p>
</blockquote>
</blockquote>
<ol start="6">
<li><p>操作系统如何申请以及管理内存的?</p>
<blockquote>
<p>虚拟内存是现代操作系统普遍使用的一项技术，很多情况下，现有内存无法满足仅仅一个大进程的内存要求(比如很多游戏都是10G+的级别)。在早期的操作系统曾使用覆盖(overlays)来解决这个问题，将一个程序分为多个块，基本思想是先将块0加入内存，块0执行完成后，将块1加入内存。以此往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力的过程。后来这个解决方案的修正版就是虚拟内存。</p>
<p>虚拟内存的基本思想是，每个进程有独立的逻辑地址空间，内存被分为大小相等的多个快，称为页。每个页都是一段连续的地址。对于进程来看，逻辑上貌似有很多内存空间，其中一部分对应物理内存的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上。</p>
</blockquote>
</li>
<li><p>简述 Linux 系统态与用户态，什么时候会进入系统态？</p>
<blockquote>
<ol>
<li><p>系统调用</p>
</li>
<li><p>发生异常，当 cpu 正在执行运行在用户的程序的时候，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核执行相关的异常事件，典型的如缺页异常。</p>
</li>
<li><p>外围设备的中断，当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU 就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>简述 LRU 算法及其实现方式</p>
<blockquote>
<p>Least Recently Used，最近最久未使用法，它是按照一个非常著名的计算机操作系统基础理论得来的：最近使用的页面数据会在未来一段时期内仍然被使用，已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。基于这个思想，会存在一种缓存淘汰机制，每次从内存中找到最久未使用的数据然后置换出来，从而存入新的数据！它的主要衡量指标是使用的时间，附加指标是使用的次数。在计算机中大量使用了这个机制，它的合理性在于优先筛选热点数据，所谓热点数据，就是最近最多使用的数据！因为，利用 LRU 我们可以解决很多实际开发中的问题，并且很符合业务。利用双向链表实现</p>
</blockquote>
</li>
<li><p>线程间有哪些通信方式</p>
<blockquote>
<p>共享变量，共享内存，共享数据库，消息队列</p>
</blockquote>
</li>
<li><p>简述同步与异步的区别，阻塞与非阻塞的区别</p>
<blockquote>
<ol>
<li><p>同步和异步</p>
<blockquote>
<p>同步和异步通常用来描述消息传递或通信的方式。</p>
<p>在同步通信中，发送方会等待接收方的响应，然后才继续发送下一条消息。相反，在异步通信中，发送方不会等待接收方的响应，而是继续发送下一条消息。</p>
</blockquote>
</li>
<li><p>阻塞与非阻塞</p>
<blockquote>
<p>阻塞与非阻塞通常用来描述系统调用的行为。系统调用是应用程序请求操作系统内核提供服务的一种机制，例如读写文件，创建进程等。</p>
<p>当一个应用程序发起一个阻塞的系统调用时，他会一直等待，直到该调用完成。相反，当一个应用程序发起一个非阻塞的系统调用时，如果该调用不能立即完成，他会立即返回。</p>
</blockquote>
</li>
</ol>
<p>总结</p>
<blockquote>
<p>同步：</p>
<blockquote>
<p>执行一个操作之后，等待结果，然后才继续执行后续的操作</p>
</blockquote>
<p>异步：</p>
<blockquote>
<p>执行一个操作之后，可以去执行其他的操作，然后等待通知再回来执行完的操作</p>
</blockquote>
<p>阻塞：</p>
<blockquote>
<p>进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作</p>
</blockquote>
<p>非阻塞：</p>
<blockquote>
<p>进程给CPU传达任务后，继续处理后续的操作，隔段时间再来询问之前的操作是否完成，这样的过程也叫轮询</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>简述操作系统中的缺页中断</p>
<blockquote>
<p>虚拟内存实际上可以比物理内存大，当访问虚拟内存时，会访问MMU(内存管理单元)去匹配对应的物理地址，而如果虚拟内存的页并不存在于物理内存中，会产生缺页中断，从磁盘中取得缺的页放入内存中，如果内存已满，还会根据页的置换算法将磁盘中的页换出。</p>
</blockquote>
</li>
<li><p>简述操作系统中 malloc 的实现原理</p>
<blockquote>
<p>malloc 基本的实现原理就是维护一个内存空闲链表，当申请内存空间时，搜索内存空闲链表，找到适配的空闲内存空间，然后将空间分割成两个内存块，一个变成分配块，一个变成新的空闲块。如果没有搜索到，那么就会用sbrk()推进brk指针来申请内存空间。</p>
<p>搜索空闲块最常见的算法有：首次适配，下一次适配，最佳适配。</p>
<p>首次适配：</p>
<blockquote>
<p>第一次找到足够大的内存块就分配，这种方法会产生很多内存碎片</p>
</blockquote>
<p>下一次适配：</p>
<blockquote>
<p>等第二次找到足够大的内存块就分配，这样会产生比较少的内存碎片</p>
</blockquote>
<p>最佳适配：</p>
<blockquote>
<p>对堆进行彻底的搜索，重投开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</p>
</blockquote>
</blockquote>
</li>
<li><p>简述 Linux 的 IO模型</p>
<blockquote>
<p>在linux操作系统中，共有五种IO模型</p>
<ul>
<li><p>阻塞IO</p>
<blockquote>
<p>应用程序在进行系统调用时会被阻塞，直到数据准备好并复制到用户空间后才返回</p>
</blockquote>
</li>
<li><p>非阻塞IO</p>
<blockquote>
<p>应用程序在进行系统调用时不会被阻塞，而是立即返回一个状态值。应用程序需要不断轮询内核以检查数据是否准备好</p>
</blockquote>
</li>
<li><p>多路复用IO</p>
<blockquote>
<p>应用程序可以同时监视多个文件描述符，当某个文件描述符就绪时，对其进行处理</p>
</blockquote>
</li>
<li><p>信号驱动IO</p>
<blockquote>
<p>应用程序向内核注册一个信号处理函数，当数据报准备好时，内核会向应用程序发送一个信号，应用程序对信号进行捕捉，并调用信号处理函数来获取数据报</p>
</blockquote>
</li>
<li><p>异步IO</p>
<blockquote>
<p>应用程序发起系统调用后立即返回，当内核将数据准备好并复制完成后会给应用程序发送通知</p>
</blockquote>
</li>
</ul>
<p>这些模型区别在于应用程序和内核之间的交互方式以及数据准备和拷贝的过程</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2023/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<ol>
<li><p>MySQL 为什么使用 B+ 树来作索引，对比 B 树它的优点和缺点是什么？</p>
<blockquote>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ol>
<li><p>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手?</p>
<blockquote>
<ul>
<li><p>三次握手</p>
<blockquote>
<p>指建立一个TCP连接时，需要客户端和服务器总共发送3个包</p>
<ol>
<li><p>客户端发送一个SYN包到服务器，并进入SYN-SEND状态</p>
</li>
<li><p>服务器收到SYN包后，回复一个SYN-ACK包，确认收到客户端的SYN包，并进入SYN-RECV状态</p>
</li>
<li><p>客户端收到服务器的SYN+ACK包后，发送一个ACK包给服务器，确认收到服务器的SYN+ACK包，此时连接建立成功</p>
</li>
</ol>
</blockquote>
</li>
<li><p>四次挥手</p>
<blockquote>
<p>指断开一个TCP连接时，需要客户端和服务器总共发送4个包</p>
<ol>
<li><p>客户端发送一个FIN包到服务器，表示客户端不在发送数据，并进入FIN-WAIT-1状态</p>
</li>
<li><p>服务器收到FIN包后，回复一个ACK包，确认收到客户端的FIN包，并进入CLOSE-WAIT状态</p>
</li>
<li><p>服务器再次发送一个FIN包给客户端，表示服务器不再发送数据，并进入LAST-ACK状态</p>
</li>
<li><p>客户端收到服务器的FIN包后，回复一个ACK包给服务器，确认收到服务器的FIN包，并进入TIME-WAIT状态。此时连接断开成功，而TIME-WAIT状态在等待2MSL后返回CLOSED状态</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>三次握手是为了防止已失效的连接请求报文突然又传送到了服务端。</p>
<p>四次挥手是为了确保数据能够完整传输。</p>
<p>为什么TIME-WAIT状态还需要等待2MSL后才能返回到CLOSED状态?</p>
<blockquote>
<ol>
<li>无法保证最后发送的ACK报文会一定被对方收到，所以需要重发可能丢失的ACK报文</li>
<li>关闭连接一段时间后可能会出现相同的IP地址和端口建立新的连接，为了防止旧连接的重复分组在新连接已经终止后再现。2msl足以让分组最多存活msl秒被丢弃</li>
</ol>
</blockquote>
<p>为什么必须是三次握手，不能用两次握手进行连接？</p>
<blockquote>
<p>两次握手容易死锁！如果服务器的应答分组在传输中丢失，S将不知道建立什么样的序列号。C认为链接还未建立成功，将忽视S发来的任何数据分组，只等待连接确认。而S在发出的分组超时后，重复发送同样的分组，这样就形成了死锁</p>
</blockquote>
</blockquote>
</li>
<li><p>Restful 与 RPC 的区别是什么? Restful 的优点在哪里?</p>
<blockquote>
<p>Restful 和 RFC 的主要区别在于 Restful 是一种用于构建web服务的架构结构，而 RFC 是一系列描述互联网及其协议的技术文档</p>
<p>Restful 基于一组原则，强调使用 HTTP 方法和资源 URL 来表示和操作资源。它还强调无状态性，这意味这每个请求应包含完成请求所需的所有信息，而不依赖于任何先前的请求</p>
<p><code>Restful: GET /order/123</code></p>
<p>RFC 是一系列描述互联网及其协议的技术文档。这些文档又互联网工程任务组(IEIF)创建，并用于定义电子邮件，文件传输和网络协议等标准</p>
<p><code>RFC: Queryorder/order_id=123</code></p>
</blockquote>
<blockquote>
<p>Restful 优点在于它是一种简单易用，高度可扩展，可移植的架构风格，可以帮助开发人员更轻松地构建web服务</p>
</blockquote>
</li>
<li><p>HTTP 与 HTTPS 有什么区别?</p>
<blockquote>
<ol>
<li><p>HTTPS 协议需要到证书颁发机构CA申请证书，HTTP 不用申请</p>
</li>
<li><p>HTTP 是长文本传输协议，属于应用层信息传输。HTTPS 则是具有 SSL 加密安全性传输协议，对数据的传输进行加密，相当于 HTTP 的升级版</p>
</li>
<li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</p>
</li>
<li><p>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输，身份认证的网络协议，比 HTTP 协议安全</p>
</li>
</ol>
</blockquote>
</li>
<li><p>HTTPS 的加密原理是什么?</p>
<blockquote>
<p>HTTPS 使用一种称为 SSL&#x2F;TLS 的协议来加密数据传输。SSL&#x2F;TLS 使用公钥加密和私钥解密的方法来保护数据的机密性和完整性</p>
<p>当客户端与服务器建立连接时，ta们会协商一种加密算法和密钥长度，然后使用该算法和密钥来加密和解密数据。这种加密方法可以防止中间人攻击和窃听，因为只有客户端和服务器知道密钥</p>
</blockquote>
</li>
<li><p>一次 HTTP 请求过程中发生了什么?</p>
<blockquote>
<p>HTTP 请求过程中发生了以下步骤:</p>
<ol>
<li><p>DNS 解析：客户端将 URL 解析为 IP 地址，以便与服务器建立连接。</p>
</li>
<li><p>建立 TCP 连接：客户端使用 TCP 协议与服务器建立连接，以便在客户端和服务器之间传输数据</p>
</li>
<li><p>发送 HTTP 请求：客户端向服务器发送 HTTP 请求，其中包括请求方法，请求头和请求体</p>
</li>
<li><p>服务器处理请求：服务器接收到 HTTP 请求后，会根据请求方法和请求 URL 来处理请求，并返回 HTTP 响应</p>
</li>
<li><p>接收 HTTP 响应：客户端接收到 HTTP 响应后，会解析响应头和响应体，并根据响应状态码来判断请求是否成功</p>
</li>
<li><p>关闭 TCP 连接：客户端和服务器之间的 TCP 连接在请求和响应完成后会被关闭</p>
</li>
</ol>
</blockquote>
</li>
<li><p>域名解析的过程是?</p>
<blockquote>
<ol>
<li><p>客户端向本地DNS服务器发送域名解析请求</p>
</li>
<li><p>如果本地DNS服务器缓存了该域名的IP地址，则直接返回该IP地址给客户端</p>
<p>如果本地DNS服务器没有缓存该域名的IP地址，则向根DNS服务器发送域名解析请求</p>
</li>
<li><p>根DNS服务器返回顶级域名服务器的IP地址给本地DNS服务器</p>
</li>
<li><p>本地DNS服务器向顶级域名服务器发送域名解析请求</p>
</li>
<li><p>顶级域名服务器返回次级域名服务器的IP地址给本地DNS服务器</p>
</li>
<li><p>本地DNS服务器向次级域名服务器发送域名解析请求</p>
</li>
<li><p>次级域名服务器返回该域名的IP地址给本地DNS服务器</p>
</li>
<li><p>本地DNS服务器将该IP地址缓存起来，并返回给客户端</p>
</li>
</ol>
</blockquote>
</li>
<li><p>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别?</p>
<blockquote>
<p>TCP 和 UDP 是传输层协议，用于在网络上传输数据。</p>
<p>它们之间的主要区别在于它们如何传输数据以及它们提供的服务类型</p>
<p>TCP(传输控制协议)：</p>
<blockquote>
<p>是一种面向连接的协议，它提供可靠的数据传输服务。它使用三次握手协议来建立连接，并使用确认和重传机制来确保数据的可靠传输。TCP 还提供流量控制和拥塞控制功能，以确保网络的稳定性和可靠性。TCP 通常用于需要可靠数据传输的应用程序</p>
</blockquote>
<p>UDP(用户数据报协议)：</p>
<blockquote>
<p>是一种无连接的协议，它提供不可靠的数据传输服务。它不使用握手协议来建立连接，也不提供确认和重传机制。UDP 不提供流量控制和拥塞控制功能，因此他通常用于需要快速数据传输的应用程序</p>
</blockquote>
</blockquote>
</li>
<li><p>TCP 中拥塞控制的实现?</p>
<blockquote>
<p>慢启动：</p>
<blockquote>
<p>在TCP连接建立后，发送方会先发送少量数据，然后逐渐增加发送数据的速率，直到网络出现拥塞为止。这样可以避免发送方一开始就发送大量数据导致网络拥塞</p>
</blockquote>
<p>拥塞避免：</p>
<blockquote>
<p>一旦网络出现拥塞，TCP会减小发送窗口的大小，以避免发送过多的数据导致网络拥塞。同时，TCP还会动态调整发送窗口的大小，以适应网络的变化</p>
</blockquote>
<p>拥塞恢复</p>
<p>快速重传</p>
<p>快速恢复</p>
</blockquote>
</li>
<li><p>TCP 怎么保证可靠传递?</p>
<blockquote>
<p>校验和</p>
<p>确认应答与序列号</p>
<p>超时重传</p>
<p>连接管理</p>
<p>流量控制：</p>
<blockquote>
<ol>
<li><p>发送方维护一个发送窗口，用于存储已发送但未被确认的数据。发送方只有在接收到接收方的确认后才能将窗口向前移动，发送更多的数据</p>
</li>
<li><p>接收方维护一个接收窗口，用于存储已接收但未被处理的数据。接收方会向发送方发送确认消息，告诉发送方已经成功接收到数据，并将接收窗口向前移动，以便接收更多的数据</p>
</li>
<li><p>发送方根据接收方发送的确认消息来动态调整发送窗口的大小，如果接收方的接收窗口变小，发送方会减小发送窗口的大小，以避免发送过多的数据导致接收方无法处理。如果接收方的接收窗口变大，发送方会增大发送窗口的大小，以提高发送数据的速率</p>
</li>
</ol>
<p>避免了发送过多数据导致接收方无法处理的情况</p>
</blockquote>
<p>拥塞控制</p>
</blockquote>
</li>
<li><p>从系统层面上看，UDP如何保证尽量可靠?</p>
<blockquote>
<p>为了在系统级别上确保可靠性，UDP实现的几种技术。</p>
<p>其中一种技术是使用校验和来检测数据中的错误。这可以通过在UDP头中添加一个校验和字段来实现，该字段是基于发送的数据计算出来的。接收方可以重新计算校验和，并将其与头部中发送的校验和进行比较，以检测任何错误</p>
<p>另一种技术是在应用程序级别实现重传。这涉及到发送方跟踪接收方已成功接受的数据包，并重新传输任何未被确认的数据包。这可以使用UDP头中的序列号来实现</p>
<p>需要注意的是，虽然这些技术可以提高可靠性，但他并不能保证可靠性。UDP仍然是一种尽力而为的协议，数据包仍然可能在传输过程中丢失或损坏。</p>
</blockquote>
</li>
<li><p>TCP 的 keepalive 了解吗？说一说它和 http 的 keepalive 的区别</p>
<blockquote>
<p>在TCP中，keepalive用于检测连接是否仍然处于活动状态。如果连接在一段时间内没有活动，则会发送一个keepalive消息，以确保连接仍然存在。这可以防止连接因为长时间没有活动而被关闭</p>
<p>在HTTP中，keepalive用于在单个TCP连接上处理多个HTTP请求，这可以减少连接建立和关闭的开销，并提高性能。在HTTP keepalive中，客户端和服务器之间的TCP连接保持打开状态，直到达到某个条件(例如超时或达到最大请求数)</p>
</blockquote>
</li>
<li><p>简述 HTTP 1.0 1.1 2.0 的主要区别</p>
<blockquote>
<p>HTTP1.0</p>
<ul>
<li>无状态，无连接</li>
</ul>
<p>HTTP1.1</p>
<ul>
<li><p>支持长连接</p>
</li>
<li><p>增加缓存处理</p>
</li>
<li><p>增加host字段</p>
</li>
<li><p>支持断点传输</p>
</li>
</ul>
<p>HTTP2.0</p>
<ul>
<li><p>二进制分帧</p>
</li>
<li><p>多路复用(连接共享)</p>
</li>
<li><p>头部压缩，encoder</p>
</li>
<li><p>服务器推送</p>
</li>
</ul>
</blockquote>
</li>
<li><p>HTTP 的方法有哪些？</p>
<blockquote>
<p>get post put delete patch</p>
</blockquote>
</li>
<li><p>简述 TCP 协议的延迟 ACK 和累计应答</p>
<blockquote>
<p>两者用于优化网络传输性能和可靠性</p>
<p>延迟 ACK 是指 TCP 接收方在接收到数据包后不立即发送 ACK 确认消息，而是等待一段时间(通常是200ms)，以便在此期间接收到其他数据包时可以一起发送 ACK。这可以减少网络流量和减轻网络负载，从而提高性能。但是，延迟 ACK 也可能导致一些问题，例如在某些情况下可能会导致数据包重传</p>
<p>累计应答是指 TCP 接收方只发送一个 ACK 消息来确认接收到的所有数据包，而不是每个数据包都发送一个 ACK。这可以减少网络流量和减轻网络负载，从而提高性能。但是累计应答也可能导致一些问题，例如在某些情况下可能会导致发送方重传已经被接收方接受的数据包</p>
</blockquote>
</li>
<li><p>简述 TCP 的报文头部结构</p>
<blockquote>
<p>16位端口号，32位序号，32位确认号，4位头部长度，6位标志位，16位窗口大小，16位校验和，16位紧急指针，TCP 头部选项</p>
</blockquote>
</li>
<li><p>简述 TCP 半连接发生场景</p>
<blockquote>
<ol>
<li><p>服务器负载过高，无法处理新的连接请求。在这种情况下，服务器可能会忽略或拒绝新的连接请求，导致客户端无法建立完整的TCP连接</p>
</li>
<li><p>防火墙或其他网络设备阻止了 SYN + ACK 包的传输。在这种情况下，客户端可能会发送多个SYN包，但服务器仍然无法回复 SYN + ACK 包，导致客户端无法建立完整的 TCP 连接</p>
</li>
</ol>
<p>解决方法:</p>
<blockquote>
<ol>
<li><p>增加服务器的处理能力，以便能够处理更多的连接请求</p>
</li>
<li><p>检查网络设备和防火墙的配置，确保它们不会阻止 SYN + ACK 包的传输</p>
</li>
<li><p>在客户端和服务器之间使用心跳机制，以便在连接空闲时保持连接状态</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>什么时 SYN flood？如何防范？</p>
<blockquote>
<p>SYN flood是一种网络攻击，攻击者通过发送大量的 SYN 包来占用服务器的资源，从而导致服务器无法处理正常的连接请求。</p>
<p>可以采取以下措施防范:</p>
<blockquote>
<ol>
<li><p>增加服务器的处理能力，以便能够处理更多的连接请求。这可以通过增加服务器的硬件资源(例如CPU, 内存，网络带宽等)或优化服务器的软件配置(例如调整服务器的网络栈参数，使用负载均衡等)来实现</p>
</li>
<li><p>使用防火墙或其他网络设备来过滤 SYN flood 攻击。这可以通过配置防火墙规则，使用 SYN cookies 等技术来实现。SYN cookies 是一种防范 SYN flood 攻击的技术，它可以在服务器端生成一个加密的 cookie，并将其发送给客户端。当客户端发送 SYN 包时，服务器可以验证 cookie 的有效性，从而防止 SYN flood 攻击</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
