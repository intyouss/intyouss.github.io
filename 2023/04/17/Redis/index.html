<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="IntYou">
    
    <meta name="author" content="IntYou">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    
        
            <link rel="preconnect" href="https://unpkg.com" crossorigin>
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://intyouss.github.io/2023/04/17/redis/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="Redis 概述 NoSQL  非关系型数据库  类型  键值存储数据库  key-value   列存储数据库  关系型数据库是典型的行存储数据库(MySQL)，按行存储的数据在物理层面占用的时连续的存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储(HBase)   文档型数据库  NoSQL 与 关系型数据库的结合(MangoDB)   图像(Graph)数据库  用于">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://intyouss.github.io/2023/04/17/Redis/index.html">
<meta property="og:site_name" content="IntYou&#39;s Blog">
<meta property="og:description" content="Redis 概述 NoSQL  非关系型数据库  类型  键值存储数据库  key-value   列存储数据库  关系型数据库是典型的行存储数据库(MySQL)，按行存储的数据在物理层面占用的时连续的存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储(HBase)   文档型数据库  NoSQL 与 关系型数据库的结合(MangoDB)   图像(Graph)数据库  用于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-19-11-22-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-19-29-07-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-19-52-54-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-19-52-28-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-20-06-24-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-20-15-57-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-20-13-59-47-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-20-14-03-19-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-20-15-07-16-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-20-15-10-56-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-20-15-12-04-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-20-21-57-57-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-21-12-28-27-image.png">
<meta property="og:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-21-13-30-57-image.png">
<meta property="article:published_time" content="2023-04-17T01:28:36.000Z">
<meta property="article:modified_time" content="2023-04-21T05:32:10.566Z">
<meta property="article:author" content="IntYou">
<meta property="article:tag" content="Redis Study">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/Lenovo/AppData/Roaming/marktext/images/2023-04-19-19-11-22-image.png">
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/avatar.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/avatar.jpg">
    <!--- Page Info-->
    
    <title>
        
            Redis -
        
        IntYou&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="https://unpkg.com/hexo-theme-redefine@2.1.1/source/assets/fonts.css">
    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"intyouss.github.io","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center"},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":["(^_^)"]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"page_pv":true},"pjax":true,"open_graph":true},"home_banner":{"enable":true,"image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Change The World As You Know","subtitle":{"text":[],"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"links":{"github":"https://github.com/intyouss","email":"intyou@outlook.com"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.1.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","announcement":null,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}}};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://unpkg.com/hexo-theme-redefine@2.1.1/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://unpkg.com/hexo-theme-redefine@2.1.1/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://unpkg.com/hexo-theme-redefine@2.1.1/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://unpkg.com/hexo-theme-redefine@2.1.1/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="IntYou's Blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                IntYou&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">Redis</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.jpg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">IntYou</span>
                            
                                <span class="author-label">(^_^)</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-04-17 09:28:36</span>
        <span class="mobile">2023-04-17 09:28</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-04-21 13:32:10</span>
            <span class="mobile">2023-04-21 13:32</span>
            <span class="hover-info">更新</span>
        </span>
    

    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Redis-Study/">Redis Study</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h2 id="Redis-概述"><a href="#Redis-概述" class="headerlink" title="Redis 概述"></a>Redis 概述</h2><hr>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><hr>
<blockquote>
<p>非关系型数据库</p>
</blockquote>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><blockquote>
<ol>
<li><p>键值存储数据库</p>
<blockquote>
<p>key-value</p>
</blockquote>
</li>
<li><p>列存储数据库</p>
<blockquote>
<p>关系型数据库是典型的行存储数据库(MySQL)，按行存储的数据在物理层面占用的时连续的存储空间，不适合海量数据存储。而按列存储则可实现分布式存储，适合海量存储(HBase)</p>
</blockquote>
</li>
<li><p>文档型数据库</p>
<blockquote>
<p>NoSQL 与 关系型数据库的结合(MangoDB)</p>
</blockquote>
</li>
<li><p>图像(Graph)数据库</p>
<blockquote>
<p>用于存放一个节点关系的数据库(Neo4J)</p>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="Redis的用途"><a href="#Redis的用途" class="headerlink" title="Redis的用途"></a>Redis的用途</h3><hr>
<h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><blockquote>
<p>减小 RT，而且降低 DBMS 的压力</p>
</blockquote>
<h5 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h5><h6 id="实时同步缓存"><a href="#实时同步缓存" class="headerlink" title="实时同步缓存"></a>实时同步缓存</h6><blockquote>
<p>指DBMS中数据更新后，Redis缓存中存放的相关数据会被立即清除，以促使再有对该数据的访问到来时，必须先从DBMS中查询获取到的最新数据，然后再写入到Redis</p>
</blockquote>
<h6 id="阶段性同步缓存"><a href="#阶段性同步缓存" class="headerlink" title="阶段性同步缓存"></a>阶段性同步缓存</h6><blockquote>
<p>指Redis缓存中的数据允许在一段时间内与DBMS中的数据不完全一致，而这个时间段就是这个缓存数据的过期时间</p>
</blockquote>
<h3 id="Redis-的-IO-模型"><a href="#Redis-的-IO-模型" class="headerlink" title="Redis 的 IO 模型"></a>Redis 的 IO 模型</h3><hr>
<blockquote>
<p>Redis 处理客户端请求所采用的处理架构，称为Redis 的 IO 模型</p>
</blockquote>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><blockquote>
<p>对于 Redis 3.0 及其以前版本，Redis 的 IO模型采用的是纯粹的单线程模型，即所有客户端的请求全部由一个线程处理，Redis 的单线程模型采用了多路复用技术</p>
</blockquote>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote>
<p>可维护性高，性能高，不存在并发读写情况，所以也就不存在执行顺序的不确定性，不存在线程切换开销，不存在死锁问题，不存在为了数据安全而进行的枷锁&#x2F;解锁开销问题</p>
</blockquote>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<p>性能会受到影响，且由于单线程只使用一个处理器，所以会形成处理器浪费</p>
</blockquote>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><blockquote>
<p>从 Redis 6.0 版本开始。处理客户端请求的仍是单线程模型，但对于一些比较耗时担又不影响对客户端的响应的操作，就由后台其他线程来处理。</p>
</blockquote>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><blockquote>
<p>其结合了多线程与单线程的优点，避开了他们的不足</p>
</blockquote>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><blockquote>
<p>该模型并非是一个真正意义上的多线程，因为真正处理任务的线程仍是单线程。所以，其对性能也是有些影响的</p>
</blockquote>
<h2 id="Redis-的配置"><a href="#Redis-的配置" class="headerlink" title="Redis 的配置"></a>Redis 的配置</h2><hr>
<h3 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a>INCLUDE</h3><hr>
<blockquote>
<p>指定要在当前配置文件中包含的配置文件。这样做的目的主要是便于配置信息管理，可以将不同场景的配置都进行单独定义，然后在当前核心配置文件中根据不同场景选择包含进不同的配置文件。</p>
<p><em>想要使用外部配置文件覆盖,可以在Redis配置文件的文件末尾 include</em></p>
<p>例：<code>include /xxx/xxx.conf</code></p>
</blockquote>
<h3 id="MODULES"><a href="#MODULES" class="headerlink" title="MODULES"></a>MODULES</h3><hr>
<blockquote>
<p>加载不同的第三方模块，来增强，扩展 Redis 的功能</p>
<p>例：<code>loadmodule /xxx/xxx/xxx/xxx.so</code></p>
</blockquote>
<h3 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h3><hr>
<blockquote>
<p>网络配置</p>
</blockquote>
<h4 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h4><blockquote>
<p>tcp-backlog 是一个 TCP 连接队列，其主要用于解决高并发场景下客户端慢连接问题。配置中设置的值就是这个队列的长度。该队列与 TCP 连接的三次握手有关。不同的 Linux 内核，backlog 队列中存放的元素(客户端连接)类型是不同的</p>
</blockquote>
<ul>
<li><p>Linux 内核 2.2 版本之前</p>
<blockquote>
<p>该队列中存放的是已完成了第一次握手的所有客户端连接，其中就包含已完成三次握手的客户端连接。当然，此时的 backlog 队列中的连接也具有两种状态：未完成三次握手的连接状态为 <code>SYN_RECEIVED</code> ，已完成三次握手的连接状态为<code>ESTABLISHED</code> 。只有 <code>ESTABLISHED</code> 状态的连接才会被 Redis 处理。</p>
</blockquote>
</li>
<li><p>Linux 内核 2.2 版本之后</p>
<blockquote>
<p>TCP 系统中维护了两个队列：<code>SYN_RECEIVED</code> 队列与 <code>ESTABLISHED</code> 队列。<code>SYN_RECEIVED</code> 队列中存放的是未完成的三次握手的连接，<code>ESTABLISHED</code> 队列中存放的是已完成三次握手的连接。此时的 backlog 就是 <code>ESTABLISHED</code> 队列</p>
</blockquote>
</li>
<li><p>TCP 中的 backlog 队列的长度在 Linux 中由内核参数 somaxconn 来决定。在 Redis 中该队列的长度由 Redis 配置文件设置 与 somaxconn 共同决定：取它们中的最小值。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 Linux 内核中 somaxconn 的值</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/net/core/somaxconn</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>生产环境下(特别是高并发场景下)，backlog 的值最好要大一些，否则可能会影响系统性能</p>
</blockquote>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改somaxconn的值</span></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">net.core.somaxconn=2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态重新加载配置</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h3><hr>
<blockquote>
<p>通用配置</p>
</blockquote>
<h4 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h4><blockquote>
<p>控制 Redis 启动是否采用守护进程方式，即是否是后台启动</p>
</blockquote>
<h4 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h4><blockquote>
<p>指定 Redis 允许是 pid 写入的文件，无论 Redis 是否采用守护进程方式启动，pid 都会写入到该配置文件</p>
<p>注意</p>
<ul>
<li><p>如果没有配置 pid 文件，不同的启动方式，pid 文件的产生效果是不同的</p>
<ul>
<li><p>采用守护进程方式启动(后台启动，daemonize 为 yes)——pid 文件为<code>/var/run/redis.pid</code></p>
</li>
<li><p>采用前台启动——不生产 pid 文件</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h4><blockquote>
<p>日志等级</p>
</blockquote>
<h4 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h4><blockquote>
<p>指定日志文件。如果设置为空串，则强制将日志记录到标准输出设备(显示器)。如果使用的是前台启动方式，设置为空串，则意味着会将日志发送到设备<code>/dev/null(空设备)</code></p>
</blockquote>
<h4 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h4><blockquote>
<p>设置数据库数量</p>
</blockquote>
<h4 id="security"><a href="#security" class="headerlink" title="security"></a>security</h4><blockquote>
<p>用户设置 ACL 权限，Redis 访问密码相关配置。该模块中最常用的就是 requirepass 属性</p>
</blockquote>
<h3 id="CLIENTS"><a href="#CLIENTS" class="headerlink" title="CLIENTS"></a>CLIENTS</h3><hr>
<blockquote>
<p>设置与客户端相关的属性</p>
</blockquote>
<h4 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h4><blockquote>
<p>设置Redis可并发处理的客户端连接数量，默认为10000，如果达到该最大连接数，则会拒绝再来的新连接，并返回一个异常消息：已达到最大连接数</p>
<p>注意</p>
<ul>
<li>该值不能超过 Linux 系统支持的可打开的文件描述符最大数量阈值</li>
</ul>
</blockquote>
<h3 id="MEMORY-MANAGEMENT"><a href="#MEMORY-MANAGEMENT" class="headerlink" title="MEMORY MANAGEMENT"></a>MEMORY MANAGEMENT</h3><hr>
<blockquote>
<p>控制最大可用内存及相关移除问题</p>
</blockquote>
<h4 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h4><blockquote>
<p>将内存使用限制设置为指定的字节数，当达到内存限制时，REdis 将根据选择的逐出策略 maxmemory-poilcy 尝试删除符合条件的key</p>
<p>如果不能按照逐出策略移除key，则会给写操作命令返回error，但对于只读的命令是没有影响的</p>
</blockquote>
<h3 id="Threaded-I-x2F-O"><a href="#Threaded-I-x2F-O" class="headerlink" title="Threaded I&#x2F;O"></a>Threaded I&#x2F;O</h3><blockquote>
<p>配置 Redis 对多线程 IO 模型的支持</p>
</blockquote>
<h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><hr>
<h3 id="Redis-基本命令"><a href="#Redis-基本命令" class="headerlink" title="Redis 基本命令"></a>Redis 基本命令</h3><hr>
<ol>
<li><p><code>dbsize</code> 查询当前数据库内容长度</p>
</li>
<li><p><code>flushdb</code> 删除当前数据库中所有数据</p>
</li>
<li><p><code>flushall</code> 删除所有数据库中所有数据</p>
</li>
<li><p><code>ping</code> 心跳命令，检测客户端与 Redis 的连接是否正常</p>
</li>
<li><p><code>set &lt;key&gt; &lt;value&gt;</code> 将指定key-value 写入到当前DB</p>
</li>
<li><p><code>get &lt;key&gt;</code> 读取指定key的value值</p>
</li>
<li><p><code>select 5</code> 选择数据库</p>
</li>
<li><p><code>quit/exit</code> 退出Redis客户端</p>
</li>
<li><p><code>redis-cli shutdown</code> 关闭Redis服务</p>
</li>
</ol>
<h3 id="Key操作命令"><a href="#Key操作命令" class="headerlink" title="Key操作命令"></a>Key操作命令</h3><hr>
<h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><ul>
<li>格式 <code>KEYS pattern</code></li>
</ul>
<blockquote>
<p>查找所有符合给定模式 pattern 的 key, pattern 为正则表达式</p>
<p>KEYS 的速度非常快，但在一个大的数据库中使用它可能会阻塞当前服务器的服务。所以生产环境中一般不使用该命令，而使用 scan 命令代替</p>
</blockquote>
<h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h4><ul>
<li>格式 <code>EXISTS key</code></li>
</ul>
<blockquote>
<p>检查给定 key 是否存在</p>
<p>若 key 存在，返回 1，反之 0</p>
</blockquote>
<h4 id="del"><a href="#del" class="headerlink" title="del"></a>del</h4><ul>
<li>格式 <code>DEL key [key ...]</code></li>
</ul>
<blockquote>
<p>删除给定的一个或多个 key。不存在的 key 会被忽略</p>
<p>返回被删除 key 的数量</p>
</blockquote>
<h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><ul>
<li>格式 <code>RENAME key newKey</code></li>
</ul>
<blockquote>
<p>将 key 改为 newKey</p>
<p>当 key 与 newKey 相同，或者 key 不存在时，返回一个错误。当 newkey 已经存在时，RENAME 命令将覆盖旧值。改名成功后提示 OK，失败时候返回一个错误</p>
</blockquote>
<h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><ul>
<li>格式 <code>MOVE key db</code></li>
</ul>
<blockquote>
<p>将当前数据库的 key 移动到给定的数据库 db 当中</p>
<p>如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果，移动成功返回 1，反之 0</p>
</blockquote>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li>格式 <code>TYPE key</code></li>
</ul>
<blockquote>
<p>返回 key 所储存的值的类型</p>
<p>返回值有以下六种</p>
<ul>
<li><p>none(key 不存在)</p>
</li>
<li><p>string</p>
</li>
<li><p>list</p>
</li>
<li><p>set</p>
</li>
<li><p>zset</p>
</li>
<li><p>hash</p>
</li>
</ul>
</blockquote>
<h4 id="expire-与-pexpire"><a href="#expire-与-pexpire" class="headerlink" title="expire 与 pexpire"></a>expire 与 pexpire</h4><ul>
<li>格式 <code>EXPIRE key seconds</code></li>
</ul>
<blockquote>
<p>为给定 key 设置生存时间。当 key 过期时(生存时间为 0)，它会被自动删除。expire 的时间单位为秒，pexpire 的时间单位为毫秒。在 Redis 中，带有生存时间的 key 被称为’易失的’(volatile)</p>
</blockquote>
<h4 id="ttl-与-pttl"><a href="#ttl-与-pttl" class="headerlink" title="ttl 与 pttl"></a>ttl 与 pttl</h4><ul>
<li>格式 <code>TTL key</code></li>
</ul>
<blockquote>
<p>TTL，time to live，返回给定 key 的剩余生存时间</p>
<p>其返回值存在三种可能</p>
<ul>
<li><p>当 key 不存在时，返回 -2</p>
</li>
<li><p>当 key 存在但没有设置剩余生存时间时，返回 -1</p>
</li>
<li><p>否则，返回 key 的剩余生存时间，ttl 命令返回的时间单位为秒，而 pttl 命令返回的时间单位为毫秒</p>
</li>
</ul>
</blockquote>
<h4 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h4><ul>
<li>格式 <code>persist key</code></li>
</ul>
<blockquote>
<p>去除给定 key 的生存时间，将这个 key 从’易失的’转换成’持久的’</p>
<p>当生存时间移除成功时，返回 1；若 key 不存在或 key 没有设置生存时间，则返回 0</p>
</blockquote>
<h4 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a>randomkey</h4><ul>
<li>格式 <code>RANDOMKEY</code></li>
</ul>
<blockquote>
<p>从当前数据库中随机返回(不删除)一个key</p>
<p>当前数据库不为空时，返回一个 key。当数据库为空时，返回nil</p>
</blockquote>
<h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><ul>
<li>格式 <code>SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</code></li>
</ul>
<blockquote>
<p>用于迭代数据库中的 key</p>
<ul>
<li><p>cursor：本次迭代开始的游标</p>
</li>
<li><p>pattern：本次迭代要匹配的 key 的模式</p>
</li>
<li><p>count：本次迭代要从数据集里返回多少元素，默认值为 10</p>
</li>
<li><p>type：本次迭代要返回的 value 的类型，默认为所有类型</p>
</li>
</ul>
<p>使用间断的，负数，超出范围的或者其他非正常的游标来执行增量式迭代</p>
<p>不会造成服务器崩溃。</p>
<p>当数据量很大时，count 的数据量的指定可能会不起作用，Redis 会自动调整每次的遍历数目。由于 scan 命令每次执行都只会返回少量元素，所以该命令可以用于生产环境</p>
</blockquote>
<h3 id="String-型-Value-操作命令"><a href="#String-型-Value-操作命令" class="headerlink" title="String 型 Value 操作命令"></a>String 型 Value 操作命令</h3><hr>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><ul>
<li>格式 <code>SET key value [EX seconds | PX milliseconds] [NX|XX]</code></li>
</ul>
<blockquote>
<p>SET 除了可以直接将 key 的值设为 value 外，还可以指定一些参数</p>
<ul>
<li><p>EX seconds：为当前 key 设置过期时间，单位秒。等价于 SETEX 命令</p>
</li>
<li><p>PX milliseconds：为当前 key 设置过期时间，单位毫秒。等价于 PSETEX 命令</p>
</li>
<li><p>NX：指定的 key 不存在才会设置成功，用于添加指定的 key。等价于 SETNX 命令</p>
</li>
<li><p>XX：指定的 key 必须存在才会设置成功，用于更新指定 key 的 value</p>
</li>
</ul>
</blockquote>
<h4 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h4><ul>
<li>格式 <code>GETSET key value</code></li>
</ul>
<blockquote>
<p>将给定 key 的值设置为value，并返回 key 的旧值</p>
<p>当 key 存在但不是字符串类型时，返回一个错误；当 key 不存在时，返回nil</p>
</blockquote>
<h4 id="mset-与-msetnx"><a href="#mset-与-msetnx" class="headerlink" title="mset 与 msetnx"></a>mset 与 msetnx</h4><ul>
<li>格式 <code>MSET/MSETNX key value [key value ...]</code></li>
</ul>
<blockquote>
<p>同时设置一个或多个 key-value 对</p>
<p>如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令；他只会在所有给定 key 都不存在的情况下进行操作操作，某些给定 key 被更新而另一些给定 key 没有改变的情况不可发生</p>
</blockquote>
<h4 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h4><ul>
<li>格式 <code>MGET key [key ...]</code></li>
</ul>
<blockquote>
<p>返回(一个或多个)给定 key 的值</p>
<p>如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 nil，因此，该命令永不失败</p>
</blockquote>
<h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><ul>
<li>格式 <code>APPEND key value</code></li>
</ul>
<blockquote>
<p>如果 key 已经存在并且是一个字符串，APPEND 命令将 value 追加到 key 原来的值的末尾。如果 key 不存在，append 就简单的将给定的 key 设为 value，就像执行 SET key value 一样</p>
<p>追加之后，返回 key 中字符串的长度</p>
</blockquote>
<h4 id="incr-与-decr"><a href="#incr-与-decr" class="headerlink" title="incr 与 decr"></a>incr 与 decr</h4><ul>
<li>格式 <code>incr key</code> 或 <code>decr key</code></li>
</ul>
<blockquote>
<p>increment 自动递增，将 key 中存储的数字值增一</p>
<p>decrement 自动递减，将 key 中存储的数字值减一</p>
<p>如果 key 不存在，那么 key 的值会先被初始化为 0，然后在执行增一&#x2F;减一操作。如果值不能表示为数字，那么返回一个错误提示。如果执行正确，则返回增一&#x2F;减一后的值</p>
</blockquote>
<h4 id="incrby-与-decrby"><a href="#incrby-与-decrby" class="headerlink" title="incrby 与 decrby"></a>incrby 与 decrby</h4><ul>
<li>格式 <code>incrby key increment</code> 或 <code>decrby key decrement</code></li>
</ul>
<blockquote>
<p>将 key 中存储的数字值增加&#x2F;减少指定的数值，这个数值只能是整数，可以是负数，但不能是小数</p>
<p>如果 key 不存在，那么 key 的值会先被初始化 0，然后再执行操作，同 incr&#x2F;decr</p>
</blockquote>
<h4 id="incrbyfloat"><a href="#incrbyfloat" class="headerlink" title="incrbyfloat"></a>incrbyfloat</h4><ul>
<li>格式 <code>incrbyfloat key increment</code></li>
</ul>
<blockquote>
<p>为 key 中所储存的值加上浮点数增量，没有 decrbyfloat</p>
</blockquote>
<h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><ul>
<li>格式 <code>strlen key</code></li>
</ul>
<blockquote>
<p>查看 key 中字符串长度</p>
</blockquote>
<h4 id="getrange"><a href="#getrange" class="headerlink" title="getrange"></a>getrange</h4><ul>
<li>格式 <code>getrange key start end</code></li>
</ul>
<blockquote>
<p>返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定，包括 start 和 end 在内</p>
<p>end 必须要比 start 大，支持负数偏移量，表示从字符串最后开始计数，-1 表示最后一个字符，以此类推</p>
</blockquote>
<h4 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h4><ul>
<li>格式 <code>setrange key offset value</code></li>
</ul>
<blockquote>
<p>用 offset 参数替换给定 key 所储存的字符串值 str，从偏移量 offset 开始</p>
<p>当 offset 值大于 str 长度时，中间使用零字节\x00填充，对于不存在的 key 当作空串处理</p>
</blockquote>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><hr>
<h4 id="数据缓存-1"><a href="#数据缓存-1" class="headerlink" title="数据缓存"></a>数据缓存</h4><blockquote>
<p>Redis 作为数据缓存层，MySQL 作为数据存储层。应用服务器首先从 Redis 中获取数据，如果缓存层中没有，则从 MySQL 中获取后先存入缓存层再返回给应用服务器</p>
</blockquote>
<h4 id="共享-Session"><a href="#共享-Session" class="headerlink" title="共享 Session"></a>共享 Session</h4><blockquote>
<p>对于一个分布式应用系统，如果将类似用户登陆信息这样的 Session 数据保存在提供登陆服务的服务器中，那么如果用户再次提交像收藏，支付等请求时可能会出现的问题：在提供收藏，支付等服务的服务器中并没有该用户的 Session 数据，从而导致该用户需要重新登录。对于用户来说这是不能接受的。</p>
<p>此时，可以将系统中所有用户的 Session 数据全部保存到 Redis 中，用户在提交新的请求后，系统先从 Redis 中查找相应的 Session 数据，如果存在，则再进行相关操作，否则跳转到登录页面。这样就不会引发’重新登录问题’</p>
</blockquote>
<h4 id="限制器"><a href="#限制器" class="headerlink" title="限制器"></a>限制器</h4><blockquote>
<p>Redis 可以结合 key 的过期时间与 incr 命令来完成限速，防止 DoS 攻击</p>
</blockquote>
<h3 id="Hash-型-Value-操作命令"><a href="#Hash-型-Value-操作命令" class="headerlink" title="Hash 型 Value 操作命令"></a>Hash 型 Value 操作命令</h3><hr>
<blockquote>
<p>Hash 表就是一个映射表 Map，也是由键-值对构成的，为了与整体的 key 进行区分，这里的键称为 field，值称为 value。注意，Redis 的 Hash 表中的 field-value 对均为 String 类型</p>
</blockquote>
<h4 id="hset"><a href="#hset" class="headerlink" title="hset"></a>hset</h4><ul>
<li>格式 <code>HSET key field value</code></li>
</ul>
<blockquote>
<p>将 hash 表 key 中的域 field 的值设为 value</p>
<p>如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作，返回1。已存在则覆盖，返回0</p>
</blockquote>
<h4 id="hget"><a href="#hget" class="headerlink" title="hget"></a>hget</h4><ul>
<li>格式 <code>hget key &lt;field&gt;</code></li>
</ul>
<blockquote>
<p>同 String</p>
</blockquote>
<h4 id="hmset"><a href="#hmset" class="headerlink" title="hmset"></a>hmset</h4><ul>
<li>格式 <code>hmset key field value [field value ...]</code></li>
</ul>
<blockquote>
<p>同 String</p>
</blockquote>
<h4 id="hmget"><a href="#hmget" class="headerlink" title="hmget"></a>hmget</h4><ul>
<li>格式 <code>hmget key field [field ...]</code></li>
</ul>
<blockquote>
<p>同 String</p>
</blockquote>
<h4 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h4><ul>
<li>格式 <code>hgetall key</code></li>
</ul>
<blockquote>
<p>获取 key 中所有 field 和 value 值</p>
</blockquote>
<h4 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h4><ul>
<li>格式 <code>hkeys key</code></li>
</ul>
<blockquote>
<p>获取 key 中所有 field 值</p>
</blockquote>
<h4 id="hlen"><a href="#hlen" class="headerlink" title="hlen"></a>hlen</h4><ul>
<li>格式 <code>hlen key</code></li>
</ul>
<blockquote>
<p>获取 key 的 长度</p>
</blockquote>
<h4 id="略-大多与String命令同"><a href="#略-大多与String命令同" class="headerlink" title="略(大多与String命令同)"></a>略(大多与String命令同)</h4><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>存储对象数据，对对象属性的修改再&#x3D;在 Redis 中就可以直接完成，其不像 String 型 Value 存储对象，那个对象是序列化过的，例如序列化为 JSON 串，对对象属性值的修改需要先反序列化为对象后再修改，修改后再序列化为 JSON 串后写入到 Redis</p>
</blockquote>
<h3 id="List-型-Value-操作命令"><a href="#List-型-Value-操作命令" class="headerlink" title="List 型 Value 操作命令"></a>List 型 Value 操作命令</h3><hr>
<h4 id="lpush-x2F-rpush"><a href="#lpush-x2F-rpush" class="headerlink" title="lpush&#x2F;rpush"></a>lpush&#x2F;rpush</h4><ul>
<li>格式 <code>LPUSH key value [value ...]</code> 或 <code>RPUSH key value [value ...]</code></li>
</ul>
<blockquote>
<p>表头&#x2F;表尾添加元素</p>
</blockquote>
<h4 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h4><ul>
<li>格式 <code>LINSERT key BEFORE|AFTER pivot value</code></li>
</ul>
<blockquote>
<p>将值 value 插入到列表 ley 当中，位于元素 pivot 之前或之后</p>
</blockquote>
<h4 id="lpop-x2F-rpop"><a href="#lpop-x2F-rpop" class="headerlink" title="lpop&#x2F;rpop"></a>lpop&#x2F;rpop</h4><ul>
<li>格式 <code>LPOP key [count]</code> 或 <code>RPOP key [count]</code></li>
</ul>
<blockquote>
<p>从列表 key 的表头&#x2F;表尾移除 count 个元素，并返回移除的元素，count 默认值 1</p>
<p>当 key 不存在时，返回 nil</p>
</blockquote>
<h4 id="blpop-x2F-brpop"><a href="#blpop-x2F-brpop" class="headerlink" title="blpop&#x2F;brpop"></a>blpop&#x2F;brpop</h4><ul>
<li>格式 <code>Blpop key [key ...] timeout</code> 或 <code>brpop key [key ..] timeout</code></li>
</ul>
<blockquote>
<p>列表的阻塞式(blocking)弹出，命令。它们是 LPOP&#x2F;RPOP 的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLpop&#x2F;Brpop 命令阻塞，知道等待 timeout 超时或发现可弹出元素为止</p>
</blockquote>
<h4 id="rpoplpush"><a href="#rpoplpush" class="headerlink" title="rpoplpush"></a>rpoplpush</h4><ul>
<li>格式 <code>rpoplpush source destnation</code></li>
</ul>
<blockquote>
<p>将source 列表的尾元素，放到 destnation 列表的表头</p>
</blockquote>
<h4 id="brpoplpush"><a href="#brpoplpush" class="headerlink" title="brpoplpush"></a>brpoplpush</h4><blockquote>
<p>rpoplpush 的阻塞版本</p>
</blockquote>
<h4 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h4><ul>
<li>格式 <code>lrem key count value</code></li>
</ul>
<blockquote>
<p>根据参数 count 的值，移除列表中与参数 value 相等的元素</p>
<p>count值为下列几种</p>
<ul>
<li><p>count &gt; 0：从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count</p>
</li>
<li><p>count &lt; 0：从表尾开始向表头搜索</p>
</li>
<li><p>count &#x3D; 0：移除表中所有与 value 相等的值</p>
</li>
</ul>
<p>返回被移除元素的数量，当 key 不存在时，返回 0</p>
</blockquote>
<h4 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h4><ul>
<li>格式 <code>LTRIM key start stop</code></li>
</ul>
<blockquote>
<p>对一个列表进行修剪，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</p>
<p>下表参数 start 和 stop 都以 0 为底，如果 start &gt; stop，返回空列表，如果 stop &lt; end,Redis 将 stop 的值设置为 end</p>
</blockquote>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<p>通过构建不同的数据结构来实现相应的业务功能</p>
<ul>
<li><p>列(lpush + lpop)</p>
</li>
<li><p>队列(lpush + rpop)</p>
</li>
<li><p>阻塞式消息队列(lpush + brpop)</p>
</li>
<li><p>动态有限集合(lpush + ltrim)</p>
</li>
</ul>
</blockquote>
<h3 id="Set-型-Value-操作命令"><a href="#Set-型-Value-操作命令" class="headerlink" title="Set 型 Value 操作命令"></a>Set 型 Value 操作命令</h3><hr>
<blockquote>
<p>Set 型的底层是 Hash 表，Set 中的元素具有无序性与不可重复性</p>
</blockquote>
<h4 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h4><ul>
<li>格式 <code>SADD key member [member ...]</code></li>
</ul>
<blockquote>
<p>将一个或多个 member 元素加入到集合 key 中，已经存在于集合的 member 元素将被忽略</p>
<p>key 不存在，则创建。当 key 不是集合类型时，返回一个错误</p>
</blockquote>
<h4 id="smembers"><a href="#smembers" class="headerlink" title="smembers"></a>smembers</h4><ul>
<li>格式 <code>SMEMBERS key</code></li>
</ul>
<blockquote>
<p>查看 key 中的所有值</p>
</blockquote>
<h4 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h4><ul>
<li>格式 <code>SCARD key</code></li>
</ul>
<blockquote>
<p>返回 Set 集合的长度</p>
</blockquote>
<h4 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h4><ul>
<li>格式 <code>SISMEMBER key member</code></li>
</ul>
<blockquote>
<p>判断 member 元素是否是集合 key 的成员</p>
</blockquote>
<h4 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h4><ul>
<li>格式 <code>SMOVE source destination member</code></li>
</ul>
<blockquote>
<p>将 member 元素从 source 集合移动到 destination 集合</p>
</blockquote>
<h4 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h4><ul>
<li>格式 <code>SREM key member [member ...]</code></li>
</ul>
<blockquote>
<p>移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略</p>
</blockquote>
<h4 id="srandmember"><a href="#srandmember" class="headerlink" title="srandmember"></a>srandmember</h4><ul>
<li>格式 <code>srandmember key [count]</code></li>
</ul>
<blockquote>
<p>在 key 中随机 count 个元素，count 默认为 1</p>
<p>count 为正数时，且小于集合长度，那么返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合长度，返回整个集合。如果 count 为负数，那么返回一个包含 count 绝对值个元素的数组，但数组中的元素可能会出现重复</p>
</blockquote>
<h4 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h4><ul>
<li>格式 <code>SPOP key [count]</code></li>
</ul>
<blockquote>
<p>移除并返回集合中的 count 个随机元素，count 必须为正数，且默认值为 1</p>
</blockquote>
<h4 id="sdiff"><a href="#sdiff" class="headerlink" title="sdiff"></a>sdiff</h4><ul>
<li>格式 <code>SDIFF key key2</code></li>
</ul>
<blockquote>
<p>差集，返回 key 相对于 key2 不同的元素</p>
</blockquote>
<h4 id="sdiffstore"><a href="#sdiffstore" class="headerlink" title="sdiffstore"></a>sdiffstore</h4><ul>
<li>格式 <code>SDIFFSTORE destination key key2</code></li>
</ul>
<blockquote>
<p>差集存储，将 key 相对于 key2 的差集存储在 destation 集合中</p>
</blockquote>
<h4 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h4><ul>
<li>格式 <code>SINTER key key2</code></li>
</ul>
<blockquote>
<p>交集，返回 key 与 key2 的交集</p>
</blockquote>
<h4 id="sinterstore"><a href="#sinterstore" class="headerlink" title="sinterstore"></a>sinterstore</h4><ul>
<li>格式 <code>SINTERSTROE destination key key2</code></li>
</ul>
<blockquote>
<p>交集存储，将 key 与 key2 的交集存储在 destination 集合中</p>
</blockquote>
<h4 id="sunion"><a href="#sunion" class="headerlink" title="sunion"></a>sunion</h4><blockquote>
<p>并集，同上</p>
</blockquote>
<h4 id="sunionstore"><a href="#sunionstore" class="headerlink" title="sunionstore"></a>sunionstore</h4><blockquote>
<p>并集存储，同上</p>
</blockquote>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><blockquote>
<ul>
<li><p>动态黑白名单</p>
</li>
<li><p>有限随机数(spop 或 srandmember)</p>
</li>
<li><p>用户画像(sadd&#x2F;sinter&#x2F;sinterstore)</p>
</li>
</ul>
</blockquote>
<h3 id="有序-Set-型-Value-操作命令-ZSet"><a href="#有序-Set-型-Value-操作命令-ZSet" class="headerlink" title="有序 Set 型 Value 操作命令(ZSet)"></a>有序 Set 型 Value 操作命令(ZSet)</h3><blockquote>
<p>Redis 存储数据的 Value 可以是一个有序的 Set，这个有序的 Set 中的每个元素均 String 类型，有序 Set 与 Set 的不同之处是，有序 Set 中的每个元素都有一个分值 scor，Redis 会根据 score 的值对集合进行由小到大的排序。其与 Set 集合要求相同，元素不能重复，但元素的 score 可以重复，由于该类型的所有命令均是 z 开头，所有该 Set 也称为 ZSet</p>
</blockquote>
<h4 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h4><ul>
<li>格式 <code>ZADD key score member [[score member] ...]</code></li>
</ul>
<blockquote>
<p>将一个或多个 member 元素以及其 score 值加入到有序 key 中的适当位置</p>
</blockquote>
<h4 id="zrange"><a href="#zrange" class="headerlink" title="zrange"></a>zrange</h4><ul>
<li>格式 <code>zrange key start end [withscores]</code></li>
</ul>
<blockquote>
<p>将集合 key 中从 start 到 end 的元素切片输出，添加 withscores 显示 key 内元素的 score 值</p>
</blockquote>
<h4 id="zrangebyscore-与-zrevrangebyscore"><a href="#zrangebyscore-与-zrevrangebyscore" class="headerlink" title="zrangebyscore 与 zrevrangebyscore"></a>zrangebyscore 与 zrevrangebyscore</h4><ul>
<li><p>格式 <code>zrangebyscore key min max [withscores] [LIMIT offset count]</code></p>
</li>
<li><p>格式 <code>zrangebyscore key max min [withscores] [LIMIT offset count]</code></p>
</li>
</ul>
<blockquote>
<p>将集合 key 中 score &gt; min，score &lt;&#x3D; max 的 元素输出，limit 按照前部分查询到的结果 从下标为 offset 开始，切片 count 数量元素并返回</p>
<p>zrevrangebyscore 是 zrangebyscore 的反向</p>
</blockquote>
<h4 id="zcard"><a href="#zcard" class="headerlink" title="zcard"></a>zcard</h4><blockquote>
<p>查询 key 集合的长度，同Set</p>
</blockquote>
<h4 id="zcount"><a href="#zcount" class="headerlink" title="zcount"></a>zcount</h4><ul>
<li>格式 <code>zcount key start end</code></li>
</ul>
<blockquote>
<p>计数 key 集合中下标 &gt; start，下标 &lt;&#x3D; end 的元素个数 </p>
</blockquote>
<h4 id="zscore"><a href="#zscore" class="headerlink" title="zscore"></a>zscore</h4><ul>
<li>格式 <code>zscore key field</code></li>
</ul>
<blockquote>
<p>查询 key 集合中 field 元素的 score 值</p>
</blockquote>
<h4 id="zrank-与-zrevrank"><a href="#zrank-与-zrevrank" class="headerlink" title="zrank 与 zrevrank"></a>zrank 与 zrevrank</h4><ul>
<li>格式 <code>zrank key field</code> 或 <code>zrevrank key field</code></li>
</ul>
<blockquote>
<p>查询 key 中 field 元素的排名，zrevrank 倒序排名</p>
</blockquote>
<h4 id="zrem-与-zremrangerank"><a href="#zrem-与-zremrangerank" class="headerlink" title="zrem 与 zremrangerank"></a>zrem 与 zremrangerank</h4><blockquote>
<p>删除 key 中元素，zremrangerank 删除 key 中一个范围内的元素</p>
</blockquote>
<h4 id="zremrangebyscore"><a href="#zremrangebyscore" class="headerlink" title="zremrangebyscore"></a>zremrangebyscore</h4><blockquote>
<p>删除 key 中 score 在一个范围内的元素</p>
</blockquote>
<h4 id="zrangebylex"><a href="#zrangebylex" class="headerlink" title="zrangebylex"></a>zrangebylex</h4><ul>
<li>格式 <code>zrangebylex key (min [max</code></li>
</ul>
<blockquote>
<p>按照第一个字母排序切片，min 和 max 前必须添加符号</p>
</blockquote>
<h4 id="zlexcount"><a href="#zlexcount" class="headerlink" title="zlexcount"></a>zlexcount</h4><blockquote>
<p>根据字母返回计数</p>
</blockquote>
<h3 id="简单动态字符串-SDS-String类型底层"><a href="#简单动态字符串-SDS-String类型底层" class="headerlink" title="简单动态字符串 SDS(String类型底层)"></a>简单动态字符串 SDS(String类型底层)</h3><hr>
<blockquote>
<p>无论是 Redis 的 Key 还是 Value，其基础数据类型都是字符串。例如，Hash 型 Value 的 field 与 value 类型，List，Set，ZSet 型 Value 的元素的类型等都是字符串。Redis 虽然是使用标准 C 语言开发，但并没有直接使用 C语言中传统的字符串表示，而是自定义了一种字符串。这种字符串本身的结构比较简单，但功能却非常强大，称为简单动态字符串 SDS</p>
<p>注意，Redis 中的所有字符串并不都是 SDS，也会出现 C 字符串，C 字符串只会出现在字符串’字面常量’中，并且该字符串不可能发生变化</p>
</blockquote>
<h4 id="SDS-结构"><a href="#SDS-结构" class="headerlink" title="SDS 结构"></a>SDS 结构</h4><blockquote>
<p>buf[] 字节数组 + len 数组中已使用字节数量 + free 数组中未使用的字节数量</p>
</blockquote>
<h4 id="SDS-的优势"><a href="#SDS-的优势" class="headerlink" title="SDS 的优势"></a>SDS 的优势</h4><ol>
<li><p>防止’字符串长度获取’性能瓶颈</p>
</li>
<li><p>保证二进制安全(‘\0’)</p>
</li>
<li><p>减少内存再分配次数</p>
<blockquote>
<p>SDS 采用了 <strong>空间预分配策略</strong> 与 <strong>惰性空间释放策略</strong> 来避免内存再分配问题</p>
<p>空间预分配策略是指，每次 SDS 进行空间扩展时，程序不但为其分配所需空间，还会为其分配额外的未使用空间，以减少内存再分配次数，而额外分配的未使用空间大小取决于空间扩展后 SDS 的 len 属性</p>
<ul>
<li><p>如果 len 属性值小于 1M，那么分配的未使用空间 free 的大小与 len 属性值相同</p>
</li>
<li><p>如果 len 属性值大于等于 1M，那么分配的未使用空间 free 的大小固定是 1M</p>
</li>
</ul>
<p>SDS 对于空间释放采用的是惰性空间释放策略，该策略是指，SDS 字符串长度如果缩短，那么多出的未使用空间将暂时不释放，而是增加到 free 中，以使后期扩展 SDS 时减少内存再分配次数</p>
<p>如果要释放 SDS 的未使用空间，则可通过 sdsREmoveFreeSpace() 函数来释放</p>
</blockquote>
</li>
<li><p>兼容 C 函数</p>
<blockquote>
<p>SDS 底层数组 buf[] 中的字符串仍以空字符’\0’结尾</p>
</blockquote>
</li>
</ol>
<h3 id="集合的底层实现原理"><a href="#集合的底层实现原理" class="headerlink" title="集合的底层实现原理"></a>集合的底层实现原理</h3><hr>
<h4 id="两种实现的选择"><a href="#两种实现的选择" class="headerlink" title="两种实现的选择"></a>两种实现的选择</h4><blockquote>
<p>对于 Hash 与 ZSet 集合，其底层的实现实际有两种：压缩列表 zipList 与 跳跃列表 skipList，这两种实现对于用户来说是透明的，但用户写入不同的数据，系统会自动使用不同的实现。只有同时满足以配置文件 redis.conf 中相关集合元素数量阈值两个条件，使用的就是压缩列表 zipList，只要有一个条件不满足使用的就是跳跃列表 skipList</p>
<p>例如，对于 ZSet 集合中这两个条件如下</p>
<ul>
<li><p>集合元素个数小于 redis.conf 中 zset-max-ziplist-entries 属性的值，其默认值为 128</p>
</li>
<li><p>每个集合元素大小都小于 redis.conf 中 zset-max-ziplist-value 属性的值，其默认值为 64字节</p>
</li>
</ul>
</blockquote>
<h4 id="zipList"><a href="#zipList" class="headerlink" title="zipList"></a>zipList</h4><ol>
<li><p>什么是 zipList</p>
<blockquote>
<p>通常称为压缩列表，是一个经过 <em>特殊编码</em> 的用于存储字符串或整数的双向链表，其底层数据结构由三部分构成：head，entries 与 end，这三部分在内存上是连续存放的</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-19-19-11-22-image.png"
                     
                ></p>
</li>
<li><p>head</p>
<blockquote>
<p>head 分为三部分</p>
<ol>
<li><p>zlbytes：占4个字节，用于存放 zipList 列表整体数据结构所占的字节数，包括 zlbytes 本身的长度</p>
</li>
<li><p>zltail：占4个字节，用于存放 zipList 中最后一个 entry 在整个数据结构中的偏移量(字节)。该数据的存在可以快速定位列表的尾 entry 位置，以方便操作</p>
</li>
<li><p>zllen：占2个字节，用于存放列表包含的 entry 个数。由于其只有 16 位，所以 zipList 最多可以含有的 entry 个数为 2^16 -1 &#x3D; 65535 个</p>
</li>
</ol>
</blockquote>
</li>
<li><p>entries</p>
<blockquote>
<p>entries 是真正的列表，有很多的列表元素 entry 构成。由于不同的元素类型，数值的不同，从而导致每个 entry 的长度不同</p>
<p>每个 entry 由三部分组成</p>
<ol>
<li><p>prevlength：该部分用于记录上一个 entry 的长度，以实现逆序遍历，默认长度为 1 字节，只要上一个 entry 的长度 &lt; 254 字节，prevlength 就占 1 字节，否则其会自动扩展为 3 字节长度</p>
</li>
<li><p>encoding：该部分用于标志后面的 data 的具体类型。如果 data 为整数类型，encoding 固定长度为 1 字节。如果 data 为字符串类型，则 encoding 长度可能会是 1 字节，2 字节或5 字节，data 字符串不同的长度，对应着不同的 encoding 长度</p>
</li>
<li><p>data：真正存储的数据。数据类型只能是整数类型或字符串类型。不同的数据占用的字节长度不同</p>
</li>
</ol>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-19-19-29-07-image.png"
                     
                ></p>
</li>
<li><p>end</p>
<blockquote>
<p>end只包含一部分，称为zlend，占 1字节，值固定为255，表示一个 zipList 列表的结束</p>
</blockquote>
</li>
</ol>
<h4 id="listPack"><a href="#listPack" class="headerlink" title="listPack"></a>listPack</h4><blockquote>
<p>对于 zipList，实现复杂，为了逆序遍历，每个 entry 中包含前一个 entry 的长度，这样会导致在 zipList 中间修改或者插入 entry 时需要进行级联更新。在高并发的写操作场景下会极度降低 Redis 的性能。为了实现更紧凑，更快的解析，更简单的实现，重写实现了 zipList，并命名为 listPack</p>
<p>在 Redis 7.0 中，已经将 zipList 全部替换为了 listPack，但为了兼容性，在配置中也保留了 zipList 的相关属性</p>
</blockquote>
<ol>
<li><p>什么是 listPack</p>
<blockquote>
<p>listPack 与 zipList 的区别在 head 与每个 entry 的结构上。表示列表结束的end 与 zipList 的 zlend 是相同的，占一个字节，且8位全为1</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-19-19-52-54-image.png"
                     
                ></p>
</li>
<li><p>head</p>
<blockquote>
<p>head 由两部分构成</p>
<ol>
<li><p>totalBytes：占 4个字节，用于存放 listPack 列表整体数据结构所占的字节数，包括 totalBytes 本身长度</p>
</li>
<li><p>elemNum：占 2字节，用于存放列表包含的 entry 个数，其意义与 zipList 中 zllen 的相同</p>
</li>
</ol>
<p>与 zipList 的 head 相比，没有了记录最后一个 entry 偏移量的 zltail。</p>
</blockquote>
</li>
<li><p>entries</p>
<blockquote>
<p>与 zipList 不同的是，没有了记录前一个 entry 长度的 prevlength，而增加了记录当前 entry 长度的 element-total-len。而这个改变仍然可以实现逆序遍历，但却避免了由于在列表中间修改或插入 entry 时引发的级联更新</p>
<p>每个 entry 仍由三部分构成</p>
<ol>
<li><p>encoding：该部分用于标志后面的 data 的具体类型，如果 data 位整数类型，encoding 长度可能会是1，2，3，4，5 或 9字节，不同的字节长度，其标识位不同。如果 data 为字符串类型，则 encoding 长度可能会是 1，2 或 5 字节，data 字符串不同的长度，对应着不同的 encoding 长度</p>
</li>
<li><p>data</p>
</li>
<li><p>element-total-len：该部分用于记录当前 entry 的长度，用于实现逆序遍历。由于其特殊的记录方式，使其本身占有的字节数据可能会是1，2，3，4 或 5字节</p>
</li>
</ol>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-19-19-52-28-image.png"
                     
                ></p>
</li>
</ol>
<h4 id="skipList"><a href="#skipList" class="headerlink" title="skipList"></a>skipList</h4><ol>
<li><p>什么时 skipList</p>
<blockquote>
<p>skipList 简称跳表，是一种 <strong>随机化</strong> 的数据结构，基于 <strong>并联</strong> 的链表，实现简单，查找效率较高，简单来说跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，也正是这个功能，使得在查找元素时，能够提供较高的效率</p>
</blockquote>
</li>
<li><p>skipList 原理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-19-20-06-24-image.png"
                     
                ></p>
<blockquote>
<p>每个节点随机分层，每多一层多一层链表，减少比较的次数</p>
</blockquote>
</li>
</ol>
<h4 id="quickList"><a href="#quickList" class="headerlink" title="quickList"></a>quickList</h4><ol>
<li><p>什么是 quickList</p>
<blockquote>
<p>quickList 快速列表，quickList 本身是一个双向无循环链表，他的每一个节点都是一个 zipList，从 Redis 3.2 版本开始，对于 List 的底层实现，使用 quickList 替代了 zipList 和 linkedList</p>
<p>quickList 本质上是 zipList 和 linkedList 的混合体，其将 linkedList 按段切分，每一段使用 zipList 来紧凑存储若干真正的数据元素，多个 zipList 之间使用双向指针串接起来，当然，对于每个 zipList 中最多可存放多大容量的数据元素，在配置文件中通过 list-max-ziplist-size 属性可以指定</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-19-20-15-57-image.png"
                     
                ></p>
</li>
<li><p>检索操作</p>
<blockquote>
<p>对于 List 元素的检索，都是以其索引 index 为依据的。quickList 由一个个的 zipList 构成，每个 zipList 的 zllen 中记录的就是当前 zipList 中包含的 entry 的个数，即包含的真正数据元素的个数。根据要检索的 index，从 quickList 的头节点开始，逐个对 zipList 的 zllen 做 sum 求和，直到找到第一个求和后 sum 大于 index 的 zipList，那么要检索的这个元素就在这个 zipList 中</p>
</blockquote>
</li>
<li><p>插入操作</p>
<blockquote>
<p>假设要插入的元素的大小为 indexBytes</p>
<ol>
<li><p>若 indexBytes + zlBytes &lt;&#x3D; zipListMaxSize，则直接将元素插入到当前找到的 zipList 中即可</p>
</li>
<li><p>若 indexBytes + zlbytes &gt; zipListMaxSize，且插入的位置在该 zipList 的首部位置，此时需要再查看该 zipList 的前一个 zipList 的大小 prev_zlBytes</p>
<ul>
<li><p>若 indexBytes + prev_zlBytes &lt;&#x3D; zipListMaxSize，则直接将元素插入到前一个 zipList 的尾部即可</p>
</li>
<li><p>若 indexBytes + prev_zlBytes &gt; zipListMaxSize，则将元素自己构建为一个 zipList，连接到 quickList</p>
</li>
</ul>
</li>
<li><p>若 indexBytes + zlbytes &gt; zipListMaxSize，且插入的位置在该 zipList 的尾部位置，此时需要再查看该 zipList 的下一个 zipList 的大小 next_zlBytes</p>
<ul>
<li><p>若 indexBytes + next_zlBytes &lt;&#x3D; zipListMaxSize，则直接将元素插入到下一个 zipList 的首部即可</p>
</li>
<li><p>若 indexBytes + next_zlBytes &gt; zipListMaxSize，则将元素自己构建为一个 zipList，连接到 quickList</p>
</li>
</ul>
</li>
<li><p>若 indexBytes + zlbytes &gt; zipListMaxSize，且插入的位置在该 zipList 的中间位置，此时需要将该 zipList 分割为两个 zipList 并连接到 quickList，然后再将元素直接插入到分割出的两个 zipList 中的前一个 zipList 的尾部位置</p>
</li>
</ol>
</blockquote>
</li>
<li><p>删除操作</p>
<blockquote>
<p>直接将节点删除即可</p>
<p>注意，如果 entry 只有一个元素，需要将 head 和 end 一起删除</p>
</blockquote>
</li>
</ol>
<h4 id="key-与-value-中元素的数量"><a href="#key-与-value-中元素的数量" class="headerlink" title="key 与 value 中元素的数量"></a>key 与 value 中元素的数量</h4><ul>
<li><p>Redis 最多可以处理 2^32 个 key，每个 Redis 实例至少可以处理 2.5 亿个 key</p>
</li>
<li><p>每个 Hash，List，Set，ZSet 集合都可以包含 2^32 个元素</p>
</li>
</ul>
<h3 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h3><hr>
<blockquote>
<p>Redis 的事务的本质是一组命令的批处理。这组命令在执行过程中会被顺序的，一次性全部执行完毕，只要没有出现语法错误，这组命令在执行期间是不会被中断</p>
</blockquote>
<h4 id="Redis-事务特性"><a href="#Redis-事务特性" class="headerlink" title="Redis 事务特性"></a>Redis 事务特性</h4><blockquote>
<p>redis 的事务仅保证了数据的一致性，不具有像 DBMS 一样的 ACID 特性</p>
</blockquote>
<ul>
<li><p>这组命令中的某些命令的执行失败不会影响其他命令的执行，不会引发 <strong>回滚</strong> 。即不具备原子性</p>
</li>
<li><p>这组命令通过乐观锁机制实现了简单的隔离性。没有复杂的隔离级别</p>
</li>
<li><p>这组命令的执行结果是被写入到内存的，是否持久取决于 Redis 的持久化策略，与事务无关</p>
</li>
</ul>
<h4 id="Redis-事务实现"><a href="#Redis-事务实现" class="headerlink" title="Redis 事务实现"></a>Redis 事务实现</h4><ol>
<li><p>三个命令</p>
<ul>
<li><p>multi：开启事务</p>
</li>
<li><p>exec：执行事务</p>
</li>
<li><p>discard：取消事务</p>
</li>
</ul>
<blockquote>
<p>exec 与 discard 不可共存</p>
</blockquote>
</li>
</ol>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><hr>
<blockquote>
<p>Redis 具有持久化功能，其会按照设置以 <strong>快照</strong> 或 <strong>操作日志</strong> 的形式将数据持久化到磁盘</p>
<p>根据持久化使用技术不同，分为两种：RDB 与 AOF</p>
</blockquote>
<h3 id="持久化-钝化-基本原理"><a href="#持久化-钝化-基本原理" class="headerlink" title="持久化(钝化)基本原理"></a>持久化(钝化)基本原理</h3><hr>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-20-13-59-47-image.png"
                     
                ></p>
<blockquote>
<p>RDB 与 AOF 可以共存，RDB 是默认持久化技术，而如果开启 AOF，则 AOF 的优先级更高</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-20-14-03-19-image.png"
                     
                ></p>
<h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><hr>
<blockquote>
<p>是指将内存中某一时刻的数据快照 <strong>全量</strong> 写入到指定的 rdb 文件的持久化技术。RDB 持久化是默认开启的。当 Redis 启动时会自动读取 RDB 快照文件，将数据从硬盘载入到内存，以恢复 Redis 关机前的数据库状态</p>
</blockquote>
<h4 id="持久化的执行"><a href="#持久化的执行" class="headerlink" title="持久化的执行"></a>持久化的执行</h4><blockquote>
<p>RDB 持久化的执行有三种方式：手动 save 命令，手动 bgsave 命令，与自动条件触发</p>
</blockquote>
<ol>
<li><p>手动 save 命令</p>
<blockquote>
<p>通过在 redis-cli 客户端中执行 save 命令可立即进行一次持久化保存。save 命令在执行期间会阻塞 redis-server 进程，直至持久化过程完毕。而在 redis-server 进程阻塞期间，redis 不能处理任何读写请求，无法对外提供服务</p>
</blockquote>
</li>
<li><p>手动 bgsave 命令</p>
<blockquote>
<p>通过在 redis-cli 客户端中执行 bgsave 命令可立即进行一次持久化保存。不同于 save 的是，可以后台允许 save。bgsave 命令会使服务器进程 redis-server 生成一个子进程，由该子进程负责完成保存过程。在子进程进行保存过程中，不会阻塞 redis-server 进程对客户端读写请求的处理</p>
</blockquote>
</li>
<li><p>自动条件触发</p>
<blockquote>
<p>本质仍是 bgsave 命令的执行。只不过是用户通过在配置文件中做相应的设置后，Redis 会根据设置信息自动调用 bgsave 命令执行。</p>
</blockquote>
</li>
<li><p>查看上次持久化的时间</p>
<ul>
<li>格式：<code>lastsave</code></li>
</ul>
</li>
</ol>
<h4 id="RDB-优化配置"><a href="#RDB-优化配置" class="headerlink" title="RDB 优化配置"></a>RDB 优化配置</h4><blockquote>
<p>参考配置文件 redis.conf 中的 SNAPSHOTTING 字段内容</p>
</blockquote>
<h4 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h4><blockquote>
<p>RDB 持久化文件 dump.rdb 分为五部分</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-20-15-07-16-image.png"
                     
                ></p>
<ol>
<li><p>SOF</p>
<blockquote>
<p>SOF 是一个常量，一个字符串 REDIS，仅包含这五个字符，其长度为 5。用于 标识 RDB 文件的开始，以便在加载 RDB 文件时可以迅速判断出文件是否是 RDB 文件</p>
</blockquote>
</li>
<li><p>rdb_version</p>
<blockquote>
<p>一个整数，长度为 4 字节，标识 RDB 文件的版本号</p>
</blockquote>
</li>
<li><p>databases</p>
<blockquote>
<p>内部包含任意多个非空数据库。而每个 database 由三部分组成</p>
<ul>
<li><p>SODB：常量，占1字节，用于标识一个数据库的开始</p>
</li>
<li><p>db_number：数据库编号</p>
</li>
<li><p>key_value_pairs：当前数据库中的键值对数据</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-20-15-10-56-image.png"
                     
                ></p>
<p>每个 key_value_pairs 又由很多个用于描述键值对的数据构成</p>
<ul>
<li><p>VALUE_TYPE：常量，占1字节，用于标识该键值对中 value 的类型</p>
</li>
<li><p>EXPIRETIME_UNIT：常量，占1字节，用于标识过期时间的单位是秒还是毫秒</p>
</li>
<li><p>time：当前 key-value 的过期时间</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-20-15-12-04-image.png"
                     
                ></p>
</blockquote>
</li>
<li><p>EOF</p>
<blockquote>
<p>一个常量，长度为 1，用于标识 RDB 数据的结束，校验和的开始</p>
</blockquote>
</li>
<li><p>check_sum</p>
<blockquote>
<p>校验和 check_sum 用于判断 RDB 文件中的内容是否出现数据异常，其采用的是 CRC 校验算法</p>
</blockquote>
</li>
</ol>
<h4 id="RDB-持久化过程"><a href="#RDB-持久化过程" class="headerlink" title="RDB 持久化过程"></a>RDB 持久化过程</h4><blockquote>
<p>对于 Redis 默认的 Redis 持久化，在进行 bgsave 持久化时，redis-server 进程会 fork 出一个 bgsave 子进程，由该子进程以异步方式负责完成持久化。而在持久化过程中，redis-server 进程不会阻塞，其会继续接收并处理用户的读写请求。</p>
<p>bgsave 子进程的详细工作原理如下</p>
<ul>
<li><p>由于子进程可以继承父进程的所有资源，且父进程不能拒绝子进程的继承权。所以，bgsave 子进程有权读取到 redis-server 进程写入到内存中的用户数据，使得将内存数据持久化到 dump.rdb 成为可能</p>
</li>
<li><p>bgsave 子进程在持久化时首先会将内存中得全量数据 copy 到磁盘中的一个 RDB 临时文件，copy 结束后，在将该文件 rename 为 dump.rdb，替换掉原来的同名文件</p>
</li>
<li><p>不过，在进行持久化过程中，如果 redis-server 进程接收到了用户写请求，则系统会将内存中发生数据修改的物理块 copy 出一个副本。等内存中的全量数据 copy 结束后，会再将副本中的数据 copy 到 RDB 临时文件。这个副本的生成是由于 Linux 系统的写时复制技术(Copy-On-Write)实现的</p>
</li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-20-21-57-57-image.png"
                     
                ></p>
<h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><hr>
<blockquote>
<p>AOF，是指 Redis 将每一次的写操作都以日志的形式记录到一个 AOF 文件中的持久性技术。当需要恢复内存数据时，将这些写操作重新执行一次，便会恢复到之前的内存数据状态</p>
</blockquote>
<h4 id="AOF-基础配置"><a href="#AOF-基础配置" class="headerlink" title="AOF 基础配置"></a>AOF 基础配置</h4><ol>
<li><p>AOF 的开启</p>
<blockquote>
<p>在 redis.conf 配置文件内将 <code>appendonly</code> 字段设置为 yes</p>
</blockquote>
</li>
<li><p>文件名配置</p>
<blockquote>
<p>包括三类多个文件</p>
<ul>
<li><p>基本文件：可以是 RDF 格式也可以是 AOF 格式。其存放的内容是由 RDB 转为 AOF 当时内存的快照数据。该文件可以有多个</p>
</li>
<li><p>增量文件：以操作日志形式记录转为 AOF 后的写入操作。该文件可以有多个</p>
</li>
<li><p>清单文件：用于维护 AOF 文件的创建顺序，保障激活时的应用顺序。该文件只有一个</p>
</li>
</ul>
</blockquote>
</li>
<li><p>混合式持久化开启</p>
<blockquote>
<p>对于基本文件可以是 RDB 格式也可以是 AOF 格式。通过 <code>aof-use-rdb-preamble</code> 属性可以选择。其默认值是 yes，即默认 AOF 持久化的基本文件为 rdb 格式文件，也就是默认采用混合式持久化</p>
</blockquote>
</li>
</ol>
<h4 id="AOF-文件格式"><a href="#AOF-文件格式" class="headerlink" title="AOF 文件格式"></a>AOF 文件格式</h4><ol>
<li><p>Redis 协议</p>
<blockquote>
<p>增量文件扩展名为.aof，采用 AOF 格式。AOF 格式其实就是 Redis 通讯协议格式，AOF 持久化文件的本质就是基于 Redis 通讯协议的文本，将命令以纯文本的方式写入到文件中</p>
<p>Redis 协议规定，Redis 文本是以行来划分，每行以\r\n 行结束。每一行都有一个我消息头，以表示消息类型。消息头由六种不同的符号表示</p>
<ul>
<li><p>(+)：表示一个正确的状态信息</p>
</li>
<li><p>(-)：表示一个错误信息</p>
</li>
<li><p>(*)：表示消息体总共有多少行，不包括当前行</p>
</li>
<li><p>($)：表示下一行消息数据的长度，不包括换行符长度\r\n</p>
</li>
<li><p>(空)：表示一个消息数据</p>
</li>
<li><p>(:)：表示返回一个数值</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="Rewrite-机制"><a href="#Rewrite-机制" class="headerlink" title="Rewrite 机制"></a>Rewrite 机制</h4><blockquote>
<p>为了防止 AOF 文件由于太大而占用大量的磁盘空间，降低性能，Redis 引入了 Rewrite 机制来对 AOF 文件进行压缩</p>
</blockquote>
<ol>
<li><p>何为 rewrite</p>
<blockquote>
<p>所谓 Rewrite 其实就是对 AOF 文件进行重写整理。当 Rewrite 开启后，主进程 redis-server 创建出一个子进程 bgrewriteaof，由该子进程完成 rewrite 过程。其首先对现有 aof 文件进行 rewrite 计算，将计算结果写入到一个临时文件，写入完毕后，再 rename 该临时文件为原 aof 文件名，覆盖原有文件</p>
</blockquote>
</li>
<li><p>rewrite 计算</p>
<blockquote>
<p>其遵循以下策略</p>
<ul>
<li><p>读操作命令不写入文件</p>
</li>
<li><p>无效命令不写入文件</p>
</li>
<li><p>过期数据不写入文件</p>
</li>
<li><p>多条命令合并写入文件</p>
</li>
</ul>
</blockquote>
</li>
<li><p>手动开启 rewrite</p>
<ul>
<li>格式 <code>bgrewriteaof</code></li>
</ul>
</li>
</ol>
<h4 id="AOF-优化配置"><a href="#AOF-优化配置" class="headerlink" title="AOF 优化配置"></a>AOF 优化配置</h4><ol>
<li><p>appendfsync</p>
<blockquote>
<p>当客户端提交写操作命令后，该命令就会写入到 aof_buf 中，而 aof_buf 中的数据持久化到磁盘 AOF 文件的过程称为数据同步。</p>
<p>可以采用以下三种不同的数据同步策略</p>
</blockquote>
<ul>
<li><p>always：写操作命令写入 aof_buf 后会立即调用 fsync() 系统函数，将其追加到 AOF 文件。该策略效率较低，但相对比较安全，不会丢失太多的数据。(生产情况不要使用)</p>
</li>
<li><p>no：写操作命令写入 aof_buf 后什么都不做，不会调用 fsync() 函数。而将 aof_buf 中的数据同步磁盘的操作由操作系统负责。Linux 系统默认同步周期为 30 秒，效率较高。</p>
</li>
<li><p>everysec：默认策略。写操作命令写入 aof_buf 后并不直接调用 fsync()，而是每秒调用一次 fsync() 系统函数来完成同步。该策略兼顾了性能与安全，是一种折中方案</p>
</li>
</ul>
</li>
<li><p>no-appendfsync-on-rewrite</p>
<blockquote>
<p>前提是 appendfsync 设置为 always 或 everysec</p>
<p>该属性用于指定，当主进程创建了子进程正在执行 bgsave 或 bgrewriteaof 时，主进程是否不调用 fsync() 来做数据同步</p>
<p>如果调用 fsync()，在需要同步的数据量非常大时，会阻塞主进程对外提供服务，可以将此命令设置为 yes，关闭 rewrite 操作，但这样也就和 <code>appendfsync no</code> 一样了</p>
</blockquote>
</li>
<li><p>aof-rewrite-incremental-fsync</p>
<blockquote>
<p>当 bgrewriteaof 在执行过程也是先将 rewrite 计算的结果写入到了 aof_rewrite_buf 缓存中，然后当缓存中数据达到一定量后就会调用 fsync() 进行刷盘操作，即数据同步，将数据写入到临时文件。该属性用于控制 fsync() 每次刷盘的数据量最大不超过 4MB。这样可以避免由于单次刷盘量过大而引发长时间堵塞</p>
</blockquote>
</li>
<li><p>aof-timestamp-enabled</p>
<blockquote>
<p>该属性设置为 yes 则会开启在 AOF 文件中增加时间戳的显示功能，可方便按照时间对数据进行恢复。但该方法可能会与 AOF 解析器不兼容，所以默认值为  no，不开启</p>
</blockquote>
</li>
<li><p>aof-load-truncated</p>
<blockquote>
<p>AOF 文件可能会在加载到内存时被截断(当操作系统崩溃时，极有可能发生。但是当 Redis 崩溃，但系统没有崩溃时，不会发生这个情况)，如果此命令设置为 yes，会重新加载 AOF 文件</p>
</blockquote>
</li>
</ol>
<h4 id="AOF-持久化过程"><a href="#AOF-持久化过程" class="headerlink" title="AOF 持久化过程"></a>AOF 持久化过程</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-21-12-28-27-image.png"
                     
                ></p>
<h3 id="RDB-与-AOF-对比"><a href="#RDB-与-AOF-对比" class="headerlink" title="RDB 与 AOF 对比"></a>RDB 与 AOF 对比</h3><hr>
<h4 id="RDB-优势与不足"><a href="#RDB-优势与不足" class="headerlink" title="RDB 优势与不足"></a>RDB 优势与不足</h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul>
<li><p>RDB 文件较小(快照)</p>
</li>
<li><p>数据恢复快</p>
</li>
</ul>
<h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><ul>
<li><p>数据安全性较差</p>
</li>
<li><p>写时复制会降低性能</p>
</li>
<li><p>RDB 文件可读性较差</p>
</li>
</ul>
<h4 id="AOF-优势与不足"><a href="#AOF-优势与不足" class="headerlink" title="AOF 优势与不足"></a>AOF 优势与不足</h4><h5 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h5><ul>
<li><p>数据安全性高</p>
</li>
<li><p>AOF 文件可读性高</p>
</li>
</ul>
<h5 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h5><ul>
<li><p>AOF 文件比较大(日志)</p>
</li>
<li><p>写操作会影响性能</p>
</li>
<li><p>数据恢复较慢(重新执行命令)</p>
</li>
</ul>
<h4 id="持久化技术的选型"><a href="#持久化技术的选型" class="headerlink" title="持久化技术的选型"></a>持久化技术的选型</h4><blockquote>
<p>官方推荐使用 RDB 与 AOF 混合式持久化。</p>
<p>若对数据安全性要求不高，则推荐使用纯 RDB 持久化方式</p>
<p>不推荐使用纯 AOF 持久化方式。</p>
<p>若 Redis 仅用于缓存，无需使用任何持久化技术</p>
</blockquote>
<h2 id="Redis-主从集群"><a href="#Redis-主从集群" class="headerlink" title="Redis 主从集群"></a>Redis 主从集群</h2><hr>
<blockquote>
<p>为了避免 Redis 的单点故障问题，我们可以搭建一个 Redis 集群，将数据备份到集群中的其他节点上。若一个 Redis 节点宕机，则由集群中的其他节点顶上</p>
</blockquote>
<h3 id="主从集群搭建"><a href="#主从集群搭建" class="headerlink" title="主从集群搭建"></a>主从集群搭建</h3><hr>
<blockquote>
<p> Redis 的主从集群是一个”一主多从”的读写分离集群。集群中的 Master 节点负责处理客户端的读写请求，而 Slave 节点仅能处理客户端的读请求。之所以要将集群搭建为读写分离模式，主要原因是对于数据库集群，写操作压力一般较小，压力大多来源于读操作请求。所以，只有一个接待你负责处理写操作请求即可</p>
</blockquote>
<h4 id="伪集群搭建与配置"><a href="#伪集群搭建与配置" class="headerlink" title="伪集群搭建与配置"></a>伪集群搭建与配置</h4><blockquote>
<p>在采用单线程 IO 模型时，为了提高处理器的利用率，一般会在一个主机中安装多台 Redis，构建一个 Redis 主从伪集群。</p>
<p>演示搭建配置：一个 Master 与 两个 Slave</p>
</blockquote>
<ol>
<li><p>复制 redis.conf</p>
</li>
<li><p>修改 redis.conf</p>
<ul>
<li><p>设置 masterauth</p>
<blockquote>
<p>主从 Redis 数据库的密码需要一致</p>
</blockquote>
</li>
<li><p>设置 repl-disable-tcp-nodelay</p>
<blockquote>
<p>该属性用于设置是否禁用 TCP 特性 tcp-nodelay。设置为 yes 则禁用，此时 Master 与 Slave 间的通信会产生延迟，但使用的 TCP 包数量会较少，占用的网络带宽会较小。反之，则网络延时变小，TCP 包数量较多，占用网络带宽较大</p>
</blockquote>
<p>tcp-nodelay</p>
<blockquote>
<p>为了充分复用网络带宽，TCP 总是希望发送尽可能大的数据块。为了达到该目的，TCP 中使用了一个叫 Nagle 的算法。</p>
<p>网络在接收到要发送的数据后，不直接发送，而是等待数据量足够大时在一次性发送出去(延迟发送)</p>
<p>此命令是 TCP 协议中 Nagle 算法的开关</p>
</blockquote>
</li>
</ul>
</li>
<li><p>新建配置文件</p>
<blockquote>
<p>将 redis.conf 中的共有属性，写入新的配置文件中，并引用源 redis.conf 文件</p>
</blockquote>
</li>
<li><p>设置主从关系</p>
<blockquote>
<p>当主从库宕机后重新启动，需要重新设置主从关系</p>
</blockquote>
<ul>
<li><p>格式 <code>slaveof ip port</code></p>
<blockquote>
<p>设置本机的主 Redis</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="分级管理"><a href="#分级管理" class="headerlink" title="分级管理"></a>分级管理</h4><blockquote>
<p>若 Redis 主从集群中的 Slave 较多时，它们的数据同步过程会对 Master 形成较大的性能压力。此时可以对 Slave 进行分级管理</p>
<p>使用 slaveof 低级 Slave 指向高级 Slave 即可</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-04-21-13-30-57-image.png"
                     
                ></p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Redis</li>
        <li><strong>作者:</strong> IntYou</li>
        <li><strong>创建于:</strong> 2023-04-17 09:28:36</li>
        
            <li>
                <strong>更新于:</strong> 2023-04-21 13:32:10
            </li>
        
        <li>
            <strong>链接:</strong> https://intyou.netlify.app/2023/04/17/Redis/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/Redis-Study/">#Redis Study</a>&nbsp;
                        </li>
                    
                </ul>
            

            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/04/12/MySQL/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">MySQL</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">Redis</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%A6%82%E8%BF%B0"><span class="nav-text">Redis 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NoSQL"><span class="nav-text">NoSQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-text">Redis的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%9A%84-IO-%E6%A8%A1%E5%9E%8B"><span class="nav-text">Redis 的 IO 模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-text">Redis 的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INCLUDE"><span class="nav-text">INCLUDE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MODULES"><span class="nav-text">MODULES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NETWORK"><span class="nav-text">NETWORK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GENERAL"><span class="nav-text">GENERAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CLIENTS"><span class="nav-text">CLIENTS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MEMORY-MANAGEMENT"><span class="nav-text">MEMORY MANAGEMENT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Threaded-I-x2F-O"><span class="nav-text">Threaded I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%91%BD%E4%BB%A4"><span class="nav-text">Redis 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="nav-text">Redis 基本命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">Key操作命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E5%9E%8B-Value-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">String 型 Value 操作命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash-%E5%9E%8B-Value-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">Hash 型 Value 操作命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-%E5%9E%8B-Value-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">List 型 Value 操作命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E5%9E%8B-Value-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="nav-text">Set 型 Value 操作命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F-Set-%E5%9E%8B-Value-%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4-ZSet"><span class="nav-text">有序 Set 型 Value 操作命令(ZSet)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-SDS-String%E7%B1%BB%E5%9E%8B%E5%BA%95%E5%B1%82"><span class="nav-text">简单动态字符串 SDS(String类型底层)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">集合的底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E4%BA%8B%E5%8A%A1"><span class="nav-text">Redis 事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">Redis 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96-%E9%92%9D%E5%8C%96-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">持久化(钝化)基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">RDB 持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">AOF 持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E4%B8%8E-AOF-%E5%AF%B9%E6%AF%94"><span class="nav-text">RDB 与 AOF 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="nav-text">Redis 主从集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="nav-text">主从集群搭建</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">IntYou</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.1.1</a>
        </div>
        
        
        
            <div id="start_div" style="display:none">
                2023/3/1 11:45:14
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>



<script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/utils.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/main.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/layouts/navbarShrink.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/tools/scrollTopBottom.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/tools/lightDarkSwitch.js"></script>


    <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/tools/localSearch.js"></script>



    <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/tools/codeBlock.js"></script>



    <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/layouts/lazyload.js"></script>



    <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/tools/runtime.js"></script>
    <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/layouts/odometer.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/hexo-theme-redefine@2.1.1/source/assets/odometer-theme-minimal.css">



  <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/libs/Typed.min.js"></script>
  <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/plugins/typed.js"></script>






<div class="post-scripts pjax">
    
        <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/tools/tocToggle.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/libs/anime.min.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/layouts/toc.js"></script><script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/plugins/tabs.js"></script>
    
</div>


    <script src="https://unpkg.com/hexo-theme-redefine@2.1.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
